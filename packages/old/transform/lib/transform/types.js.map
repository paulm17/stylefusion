{"version":3,"file":"types.js","names":["Pending","exports","Symbol"],"sources":["../../src/transform/types.ts"],"sourcesContent":["import type { BabelFileResult } from '@babel/core';\n\nimport type { ValueCache } from '@wyw-in-js/processor-utils';\nimport type { Debugger, Artifact, StrictOptions } from '@wyw-in-js/shared';\n\nimport type { Core } from '../babel';\nimport type { TransformCacheCollection } from '../cache';\nimport type { Options, ITransformFileResult } from '../types';\nimport type { EventEmitter } from '../utils/EventEmitter';\nimport type { WYWTransformMetadata } from '../utils/TransformMetadata';\n\nimport type { Entrypoint } from './Entrypoint';\nimport type { LoadAndParseFn, IEntrypointDependency } from './Entrypoint.types';\nimport type { BaseAction } from './actions/BaseAction';\nimport type {\n  IExtracted,\n  IWorkflowActionLinariaResult,\n  IWorkflowActionNonLinariaResult,\n} from './actions/types';\n\nexport type Services = {\n  babel: Core;\n  cache: TransformCacheCollection;\n  eventEmitter: EventEmitter;\n  loadAndParseFn: LoadAndParseFn;\n  log: Debugger;\n  options: Options & {\n    pluginOptions: StrictOptions;\n  };\n};\n\nexport interface IBaseNode {\n  type: ActionTypes;\n}\n\nexport type ActionByType<TType extends ActionQueueItem['type']> = Extract<\n  ActionQueueItem,\n  {\n    type: TType;\n  }\n>;\n\nexport const Pending = Symbol('pending');\n\nexport type YieldResult = Exclude<ActionQueueItem['result'], typeof Pending>;\n\nexport type AnyIteratorResult<TMode extends 'async' | 'sync', TResult> = {\n  async: Promise<IteratorResult<YieldArg, TResult>>;\n  sync: IteratorResult<YieldArg, TResult>;\n}[TMode];\n\nexport interface IBaseAction<TAction extends ActionQueueItem, TResult, TData>\n  extends IBaseNode {\n  abortSignal: AbortSignal | null;\n  createAbortSignal: () => AbortSignal & Disposable;\n  data: TData;\n  entrypoint: Entrypoint;\n  getNext: GetNext;\n  idx: string;\n  result: TResult | typeof Pending;\n  run: <TMode extends 'async' | 'sync'>(\n    handler: Handler<TMode, TAction>\n  ) => {\n    next: (arg: YieldResult) => AnyIteratorResult<TMode, TResult>;\n    throw(e: unknown): AnyIteratorResult<TMode, TResult>;\n  };\n  services: Services;\n}\n\ntype NextParams<\n  TType extends ActionTypes,\n  TNextAction extends ActionByType<TType> = ActionByType<TType>,\n> = [\n  type: TType,\n  entrypoint: Entrypoint,\n  data: TNextAction['data'],\n  abortSignal?: AbortSignal | null,\n];\n\nexport type YieldArg = {\n  [K in ActionQueueItem['type']]: NextParams<K>;\n}[ActionQueueItem['type']];\n\nexport type SyncScenarioFor<TResult> = {\n  [Symbol.iterator](): SyncScenarioFor<TResult>;\n  next(arg: YieldResult): IteratorResult<YieldArg, TResult>;\n  return(value: TResult): IteratorResult<YieldArg, TResult>;\n  throw(e: unknown): IteratorResult<YieldArg, TResult>;\n};\n\nexport type AsyncScenarioFor<TResult> = {\n  [Symbol.asyncIterator](): AsyncScenarioFor<TResult>;\n  next(arg: YieldResult): Promise<IteratorResult<YieldArg, TResult>>;\n  return(\n    value: TResult | PromiseLike<TResult>\n  ): Promise<IteratorResult<YieldArg, TResult>>;\n  throw(e: unknown): Promise<IteratorResult<YieldArg, TResult>>;\n};\n\nexport type SyncScenarioForAction<TAction extends ActionQueueItem> =\n  SyncScenarioFor<TypeOfResult<TAction>>;\n\nexport type AsyncScenarioForAction<TAction extends ActionQueueItem> =\n  AsyncScenarioFor<TypeOfResult<TAction>>;\n\nexport type Handler<\n  TMode extends 'async' | 'sync',\n  TAction extends ActionQueueItem,\n> = ((this: BaseAction<TAction>) => {\n  async: AsyncScenarioForAction<TAction>;\n  sync: SyncScenarioForAction<TAction>;\n}[TMode]) & {\n  recover?: (e: unknown, action: BaseAction<TAction>) => YieldArg;\n};\n\nexport type Handlers<TMode extends 'async' | 'sync'> = {\n  [TAction in ActionQueueItem as TAction['type']]: Handler<TMode, TAction>;\n};\n\nexport type TypeOfResult<T extends ActionQueueItem> = Exclude<\n  T['result'],\n  typeof Pending\n>;\n\nexport type GetNext = <\n  TType extends ActionTypes,\n  TNextAction extends ActionByType<TType> = ActionByType<TType>,\n>(\n  ...args: NextParams<TType, TNextAction>\n) => Generator<\n  [TType, Entrypoint, TNextAction['data'], AbortSignal | null],\n  TypeOfResult<TNextAction>,\n  YieldResult\n>;\n\nexport interface ICollectActionResult {\n  ast: BabelFileResult['ast']; // FIXME: looks like this is not used\n  code: BabelFileResult['code'];\n  map?: BabelFileResult['map'];\n  metadata?: WYWTransformMetadata | null;\n}\n\nexport interface ICollectAction\n  extends IBaseAction<\n    ICollectAction,\n    ICollectActionResult,\n    { valueCache: ValueCache }\n  > {\n  type: 'collect';\n}\n\nexport interface IEvalAction\n  extends IBaseAction<IEvalAction, [ValueCache, string[]] | null, undefined> {\n  type: 'evalFile';\n}\n\nexport interface IExplodeReexportsAction\n  extends IBaseAction<IExplodeReexportsAction, void, undefined> {\n  type: 'explodeReexports';\n}\n\nexport interface IExtractAction\n  extends IBaseAction<\n    IExtractAction,\n    IExtracted,\n    { processors: { artifacts: Artifact[] }[] }\n  > {\n  type: 'extract';\n}\n\nexport interface IGetExportsAction\n  extends IBaseAction<IGetExportsAction, string[], undefined> {\n  type: 'getExports';\n}\n\nexport interface IProcessEntrypointAction\n  extends IBaseAction<IProcessEntrypointAction, void, undefined> {\n  type: 'processEntrypoint';\n}\n\nexport interface IProcessImportsAction\n  extends IBaseAction<\n    IProcessImportsAction,\n    void,\n    {\n      resolved: IEntrypointDependency[];\n    }\n  > {\n  type: 'processImports';\n}\n\nexport interface IResolveImportsAction\n  extends IBaseAction<\n    IResolveImportsAction,\n    IEntrypointDependency[],\n    {\n      imports: Map<string, string[]> | null;\n    }\n  > {\n  type: 'resolveImports';\n}\n\nexport interface ITransformAction\n  extends IBaseAction<ITransformAction, ITransformFileResult, undefined> {\n  type: 'transform';\n}\n\nexport interface IWorkflowAction\n  extends IBaseAction<\n    IWorkflowAction,\n    IWorkflowActionLinariaResult | IWorkflowActionNonLinariaResult,\n    undefined\n  > {\n  type: 'workflow';\n}\n\nexport type ActionQueueItem =\n  | IEvalAction\n  | IExplodeReexportsAction\n  | IExtractAction\n  | IGetExportsAction\n  | ICollectAction\n  | IProcessEntrypointAction\n  | IProcessImportsAction\n  | IResolveImportsAction\n  | ITransformAction\n  | IWorkflowAction;\n\nexport type ActionTypes = ActionQueueItem['type'];\n"],"mappings":";;;;;;AA0CO,MAAMA,OAAO,GAAAC,OAAA,CAAAD,OAAA,GAAGE,MAAM,CAAC,SAAS,CAAC","ignoreList":[]}