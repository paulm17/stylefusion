{"version":3,"file":"explodeReexports.js","names":["_generator","_interopRequireDefault","require","_getExports","obj","__esModule","default","getWildcardReexport","babel","ast","reexportsFrom","program","body","forEach","node","types","isExportAllDeclaration","source","isStringLiteral","push","value","explodeReexports","services","log","loadedAndParsed","entrypoint","evaluator","length","resolvedImports","getNext","imports","Map","map","i","importedEntrypoints","findExportsInImports","replacements","importedEntrypoint","exports","undefined","reexport","find","import","set","exportNamedDeclaration","exportSpecifier","identifier","stringLiteral","traverse","ExportAllDeclaration","path","replacement","get","replaceWith","remove","code","generate"],"sources":["../../../src/transform/generators/explodeReexports.ts"],"sourcesContent":["import generate from '@babel/generator';\nimport type { ExportAllDeclaration, File, Node } from '@babel/types';\n\nimport type { Core } from '../../babel';\nimport type { IExplodeReexportsAction, SyncScenarioForAction } from '../types';\n\nimport { findExportsInImports } from './getExports';\n\nconst getWildcardReexport = (babel: Core, ast: File) => {\n  const reexportsFrom: { node: ExportAllDeclaration; source: string }[] = [];\n  ast.program.body.forEach((node) => {\n    if (\n      babel.types.isExportAllDeclaration(node) &&\n      node.source &&\n      babel.types.isStringLiteral(node.source)\n    ) {\n      reexportsFrom.push({\n        source: node.source.value,\n        node,\n      });\n    }\n  });\n\n  return reexportsFrom;\n};\n\n/**\n * Replaces wildcard reexports with named reexports.\n * Recursively emits getExports for each reexported module,\n * and replaces wildcard with resolved named.\n */\nexport function* explodeReexports(\n  this: IExplodeReexportsAction\n): SyncScenarioForAction<IExplodeReexportsAction> {\n  const { babel } = this.services;\n  const { log, loadedAndParsed } = this.entrypoint;\n  if (loadedAndParsed.evaluator === 'ignored') {\n    return;\n  }\n\n  const reexportsFrom = getWildcardReexport(babel, loadedAndParsed.ast);\n  if (!reexportsFrom.length) {\n    return;\n  }\n\n  log('has wildcard reexport from %o', reexportsFrom);\n\n  const resolvedImports = yield* this.getNext(\n    'resolveImports',\n    this.entrypoint,\n    {\n      imports: new Map(reexportsFrom.map((i) => [i.source, []])),\n    }\n  );\n\n  const importedEntrypoints = findExportsInImports(\n    this.entrypoint,\n    resolvedImports\n  );\n\n  const replacements = new Map<ExportAllDeclaration, Node | null>();\n  for (const importedEntrypoint of importedEntrypoints) {\n    const exports = yield* this.getNext(\n      'getExports',\n      importedEntrypoint.entrypoint,\n      undefined\n    );\n\n    const reexport = reexportsFrom.find(\n      (i) => i.source === importedEntrypoint.import\n    );\n    if (reexport) {\n      replacements.set(\n        reexport.node,\n        exports.length\n          ? babel.types.exportNamedDeclaration(\n              null,\n              exports.map((i) =>\n                babel.types.exportSpecifier(\n                  babel.types.identifier(i),\n                  babel.types.identifier(i)\n                )\n              ),\n              babel.types.stringLiteral(importedEntrypoint.import)\n            )\n          : null\n      );\n    }\n  }\n\n  // Replace wildcard reexport with named reexports\n  babel.traverse(loadedAndParsed.ast, {\n    ExportAllDeclaration(path) {\n      const replacement = replacements.get(path.node);\n      if (replacement) {\n        path.replaceWith(replacement);\n      } else {\n        path.remove();\n      }\n    },\n  });\n\n  loadedAndParsed.code = generate(loadedAndParsed.ast).code;\n}\n"],"mappings":"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","ignoreList":[]}