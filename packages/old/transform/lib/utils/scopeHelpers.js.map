{"version":3,"file":"scopeHelpers.js","names":["_types","require","_findIdentifiers","_getScope","_isNotNull","_isRemoved","validateField","node","key","val","field","console","log","validate","optional","getBinding","path","binding","getScope","name","undefined","reference","referencePath","force","isReferencedIdentifier","referencePaths","includes","referenced","push","references","length","isReferenced","kind","isFunctionExpression","parentPath","isVariableDeclarator","id","get","isIdentifier","idBinding","every","i","find","ancestor","isTSType","isFlowType","isReferencedConstantViolation","p","isAssignmentExpression","isExpressionStatement","dereference","isReference","referencesInConstantViolations","constantViolations","filter","isConstantViolation","nonTypeReferences","nonType","dereferenceAll","findIdentifiers","map","identifierPath","isNotNull","referenceAll","forEach","deletingNodes","WeakSet","isEmptyList","list","has","getPathFromAction","action","Array","isArray","Error","isPrototypeAssignment","left","type","object","property","canFunctionBeDelete","fnPath","fnScope","scope","parentScope","parent","listKey","findActionForNode","isRemoved","add","isProgram","isClassDeclaration","isClassExpression","body","isFunction","isBlockStatement","async","directives","generator","params","isConditionalExpression","alternate","isLogicalExpression","operator","value","right","isObjectProperty","maybeDefineProperty","isCallExpression","matchesPattern","isTemplateLiteral","isForInStatement","isFunctionDeclaration","isObjectMethod","isClassMethod","prevStatement","isIfStatement","isReturnStatement","slice","statement","init","isExportNamedDeclaration","declaration","isTryStatement","NODE_FIELDS","referenceEnums","program","traverse","ExpressionStatement","expressionStatement","expression","callee","args","arg","fixed","removeUnreferenced","items","Set","item","hasReferences","forDeleting","identifier","removeWithRelated","result","sort","a","b","_a$node","_b$node","localeCompare","getNodeForValue","staticEvaluate","evaluated","evaluate","confident","applyAction","test","isBooleanLiteral","consequent","mutate","remove","replaceWith","paths","rootPath","getProgramParent","actions","affectedPaths","referencedIdentifiers","_a$node2","_b$node2","referencesOfBinding","_ref","reduce","acc","ref","isExportDefaultDeclaration","clean","_i$node","join","_i$node2","fn","dereferenced","mutated","dead","assignments","assignment","declared","Object","values","getOuterBindingIdentifiers","_assignment$parentPat","_scope$getBinding","Identifier","isArrayPattern","elements"],"sources":["../../src/utils/scopeHelpers.ts"],"sourcesContent":["/* eslint-disable no-restricted-syntax */\n/* eslint @typescript-eslint/no-use-before-define: [\"error\", { \"functions\": false }] */\n\nimport type { Binding, NodePath } from '@babel/traverse';\nimport type {\n  FieldOptions,\n  Function as FunctionNode,\n  Identifier,\n  JSXIdentifier,\n  Node,\n  Program,\n} from '@babel/types';\nimport { NODE_FIELDS } from '@babel/types';\n\nimport { findIdentifiers, nonType } from './findIdentifiers';\nimport { getScope } from './getScope';\nimport { isNotNull } from './isNotNull';\nimport { isRemoved } from './isRemoved';\n\nfunction validateField(\n  node: Node,\n  key: string,\n  val: unknown,\n  field: FieldOptions\n) {\n  console.log(\"scopeHelpers - validateField\");\n  if (!(field != null && field.validate)) return true;\n  if (field.optional && val == null) return true;\n  try {\n    field.validate(node, key, val);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\nfunction getBinding(path: NodePath<Identifier | JSXIdentifier>) {\n  console.log(\"scopeHelpers - getBinding\");\n  const binding = getScope(path).getBinding(path.node.name);\n  if (!binding) {\n    return undefined;\n  }\n\n  return binding;\n}\n\nexport function reference(\n  path: NodePath<Identifier | JSXIdentifier>,\n  referencePath: NodePath = path,\n  force = false\n): void {\n  console.log(\"scopeHelpers - reference\");\n  if (!force && !path.isReferencedIdentifier()) return;\n\n  const binding = getBinding(path);\n  if (!binding) return;\n\n  if (binding.referencePaths.includes(referencePath)) {\n    return;\n  }\n\n  binding.referenced = true;\n  binding.referencePaths.push(referencePath ?? path);\n  binding.references = binding.referencePaths.length;\n}\n\nfunction isReferenced(binding: Binding): boolean {\n  console.log(\"scopeHelpers - isReferenced\");\n  const { kind, referenced, referencePaths, path } = binding;\n\n  if (\n    path.isFunctionExpression() &&\n    path.key === 'init' &&\n    path.parentPath.isVariableDeclarator()\n  ) {\n    // It is a function expression in a variable declarator\n    const id = path.parentPath.get('id');\n    if (id.isIdentifier()) {\n      const idBinding = getBinding(id);\n      return idBinding ? isReferenced(idBinding) : true;\n    }\n\n    return true;\n  }\n\n  if (!referenced) {\n    return false;\n  }\n\n  // If it's a param binding, we can't just remove it\n  // because it brakes the function signature. Keep it alive for now.\n  if ((kind as string) === 'param') {\n    return true;\n  }\n\n  // If all remaining references are in TS/Flow types, binding is unreferenced\n  return (\n    referencePaths.length > 0 ||\n    referencePaths.every((i) =>\n      i.find((ancestor) => ancestor.isTSType() || ancestor.isFlowType())\n    )\n  );\n}\n\nfunction isReferencedConstantViolation(path: NodePath, binding: Binding) {\n  console.log(\"scopeHelpers - isReferencedConstantViolation\");\n  if (path.find((p) => p === binding.path)) {\n    // function a(flag) { return (a = function(flag) { flag ? 1 : 2 }) }\n    // ^ Looks crazy, yeh? Welcome to the wonderful world of transpilers!\n    // `a = â€¦` here isn't a reference.\n    return false;\n  }\n\n  if (!path.isReferenced()) {\n    return false;\n  }\n\n  if (\n    path.isAssignmentExpression() &&\n    path.parentPath.isExpressionStatement()\n  ) {\n    // A root assignment without a parent expression statement is not a reference\n    return false;\n  }\n\n  return true;\n}\n\nexport function dereference(\n  path: NodePath<Identifier | JSXIdentifier>\n): Binding | null {\n  console.log(\"scopeHelpers - dereference\");\n  const binding = getBinding(path);\n  if (!binding) return null;\n\n  const isReference = binding.referencePaths.includes(path);\n  let referencesInConstantViolations = binding.constantViolations.filter((i) =>\n    isReferencedConstantViolation(i, binding)\n  );\n\n  const isConstantViolation = referencesInConstantViolations.includes(path);\n\n  if (!isReference && !isConstantViolation) {\n    return null;\n  }\n\n  if (isReference) {\n    binding.referencePaths = binding.referencePaths.filter((i) => i !== path);\n    binding.references -= 1;\n  } else {\n    referencesInConstantViolations = referencesInConstantViolations.filter(\n      (i) => i !== path\n    );\n  }\n\n  const nonTypeReferences = binding.referencePaths.filter(nonType);\n  binding.referenced =\n    nonTypeReferences.length + referencesInConstantViolations.length > 0;\n\n  return binding;\n}\n\nfunction dereferenceAll(path: NodePath): Binding[] {\n  console.log(\"scopeHelpers - dereferenceAll\");\n  return findIdentifiers([path])\n    .map((identifierPath) => dereference(identifierPath))\n    .filter(isNotNull);\n}\n\nexport function referenceAll(path: NodePath): void {\n  console.log(\"scopeHelpers - referenceAll\");\n  findIdentifiers([path]).forEach((identifierPath) =>\n    reference(identifierPath)\n  );\n}\n\nconst deletingNodes = new WeakSet<NodePath>();\n\nconst isEmptyList = (list: NodePath[]) =>\n  list.length === 0 || list.every((i) => deletingNodes.has(i));\n\ntype ReplaceAction = [action: 'replace', what: NodePath, by: Node];\ntype RemoveAction = [action: 'remove', what: NodePath];\n\nconst getPathFromAction = (action: RemoveAction | ReplaceAction) => {\n  console.log(\"scopeHelpers - getPathFromAction\");\n  if (!Array.isArray(action)) {\n    return action;\n  }\n\n  if (action[0] === 'replace' || action[0] === 'remove') {\n    return action[1];\n  }\n\n  throw new Error(`Unknown action type: ${action[0]}`);\n};\n\nfunction isPrototypeAssignment(path: NodePath) {\n  console.log(\"scopeHelpers - isPrototypeAssignment\");\n  if (!path.isAssignmentExpression()) {\n    return false;\n  }\n\n  const { left } = path.node;\n  if (!left) {\n    return false;\n  }\n\n  if (left.type !== 'MemberExpression') {\n    return false;\n  }\n\n  const { object, property } = left;\n  if (!object || !property) {\n    return false;\n  }\n\n  return (\n    object.type === 'MemberExpression' &&\n    object.property.type === 'Identifier' &&\n    object.property.name === 'prototype'\n  );\n}\n\nfunction canFunctionBeDelete(fnPath: NodePath<FunctionNode>) {\n  console.log(\"scopeHelpers - canFunctionBeDelete\");\n  if (isPrototypeAssignment(fnPath.parentPath)) {\n    // It is a prototype assignment, we can't delete it since we can't find all usages\n    return false;\n  }\n\n  const fnScope = fnPath.scope;\n  const parentScope = fnScope.parent;\n  if (parentScope.parent) {\n    // It isn't a top-level function, so we can't delete it\n    return true;\n  }\n\n  if (fnPath.listKey === 'arguments') {\n    // It is passed as an argument to another function, we can't delete it\n    return true;\n  }\n\n  return false;\n}\n\nexport function findActionForNode(\n  path: NodePath\n): RemoveAction | ReplaceAction | null {\n  console.log(\"scopeHelpers - findActionForNode\");\n  if (isRemoved(path)) return null;\n\n  deletingNodes.add(path);\n\n  const parent = path.parentPath;\n\n  if (!parent) return ['remove', path];\n\n  if (parent.isProgram()) {\n    // Do not delete Program node\n    return ['remove', path];\n  }\n\n  if (parent.isClassDeclaration() || parent.isClassExpression()) {\n    if (path.key === 'body') {\n      return ['replace', path, { type: 'ClassBody', body: [] }];\n    }\n  }\n\n  if (parent.isFunction()) {\n    if (path.listKey === 'params') {\n      // Do not remove params of functions\n      return null;\n    }\n\n    if (\n      (path.isBlockStatement() && isEmptyList(path.get('body'))) ||\n      path === parent.get('body')\n    ) {\n      if (!canFunctionBeDelete(parent)) {\n        return [\n          'replace',\n          parent,\n          {\n            ...parent.node,\n            async: false,\n            body: {\n              type: 'BlockStatement',\n              body: [],\n              directives: [],\n            },\n            generator: false,\n            params: [],\n          },\n        ];\n      }\n    }\n  }\n\n  if (parent.isConditionalExpression()) {\n    if (path.key === 'test') {\n      return ['replace', parent, parent.node.alternate];\n    }\n\n    if (path.key === 'consequent') {\n      return ['replace', path, { type: 'Identifier', name: 'undefined' }];\n    }\n\n    if (path.key === 'alternate') {\n      return ['replace', path, { type: 'Identifier', name: 'undefined' }];\n    }\n  }\n\n  if (parent.isLogicalExpression({ operator: '&&' })) {\n    return [\n      'replace',\n      parent,\n      {\n        type: 'BooleanLiteral',\n        value: false,\n      },\n    ];\n  }\n\n  if (parent.isLogicalExpression({ operator: '||' })) {\n    return [\n      'replace',\n      parent,\n      path.key === 'left' ? parent.node.right : parent.node.left,\n    ];\n  }\n\n  if (parent.isObjectProperty()) {\n    // let's check if it is a special case with Object.defineProperty\n    const key = parent.get('key');\n    if (key.isIdentifier({ name: 'get' })) {\n      const maybeDefineProperty = parent.parentPath.parentPath;\n      if (\n        maybeDefineProperty?.isCallExpression() &&\n        maybeDefineProperty\n          .get('callee')\n          .matchesPattern('Object.defineProperty')\n      ) {\n        return findActionForNode(maybeDefineProperty);\n      }\n    }\n\n    return findActionForNode(parent);\n  }\n\n  if (parent.isTemplateLiteral()) {\n    return [\n      'replace',\n      path,\n      {\n        type: 'StringLiteral',\n        value: '',\n      },\n    ];\n  }\n\n  if (parent.isAssignmentExpression()) {\n    if (path.isAssignmentExpression()) {\n      // `foo = bar = 42` should be replaced with `foo = 42`\n      return ['replace', path, path.node.right];\n    }\n\n    return findActionForNode(parent);\n  }\n\n  if (parent.isCallExpression()) {\n    return findActionForNode(parent);\n  }\n\n  if (parent.isForInStatement({ left: path.node })) {\n    return findActionForNode(parent);\n  }\n\n  if (\n    parent.isFunctionExpression({ body: path.node }) ||\n    parent.isFunctionDeclaration() ||\n    parent.isObjectMethod() ||\n    parent.isClassMethod()\n  ) {\n    return findActionForNode(parent);\n  }\n\n  if (parent.isBlockStatement()) {\n    const body = parent.get('body');\n    if (isEmptyList(body)) {\n      return findActionForNode(parent);\n    }\n\n    if (path.listKey === 'body' && typeof path.key === 'number') {\n      if (path.key > 0) {\n        // We can check whether the previous one can be removed\n        const prevStatement = body[path.key - 1];\n        if (\n          prevStatement.isIfStatement() &&\n          prevStatement.get('consequent').isReturnStatement()\n        ) {\n          // It's `if (â€¦) return â€¦`, we can remove it.\n          return findActionForNode(prevStatement);\n        }\n      } else if (\n        body.slice(1).every((statement) => deletingNodes.has(statement))\n      ) {\n        // If it is the first statement and all other statements\n        // are marked for deletion, we can remove the whole block.\n        return findActionForNode(parent);\n      }\n    }\n  }\n\n  if (parent.isVariableDeclarator()) {\n    if (path.key === 'init' && path.isAssignmentExpression()) {\n      // We are removing `bar` in `var foo = bar = 42`. Path should be replaced with `var foo = 42`\n      return ['replace', path, path.node.right];\n    }\n\n    const init = parent.get('init');\n    if (path.key === 'id' && init.isAssignmentExpression()) {\n      // We are removing `foo` in `var foo = bar = 42`. Ignore it.\n      return null;\n    }\n\n    return findActionForNode(parent);\n  }\n\n  if (\n    parent.isExportNamedDeclaration() &&\n    ((path.key === 'specifiers' && isEmptyList(parent.get('specifiers'))) ||\n      (path.key === 'declaration' && parent.node.declaration === path.node))\n  ) {\n    return findActionForNode(parent);\n  }\n\n  for (const key of ['body', 'declarations', 'specifiers']) {\n    if (path.listKey === key && typeof path.key === 'number') {\n      const list = parent.get(key) as NodePath[];\n      if (isEmptyList(list)) {\n        return findActionForNode(parent);\n      }\n    }\n  }\n\n  if (parent.isTryStatement()) {\n    return findActionForNode(parent);\n  }\n\n  if (!path.listKey && path.key) {\n    const field = NODE_FIELDS[parent.type][path.key];\n    if (!validateField(parent.node, path.key as string, null, field)) {\n      // The parent node isn't valid without this field, so we should remove it also.\n      return findActionForNode(parent);\n    }\n  }\n\n  for (const key of [\n    'argument',\n    'block',\n    'body',\n    'callee',\n    'discriminant',\n    'expression',\n    'id',\n    'left',\n    'object',\n    'property',\n    'right',\n    'test',\n  ]) {\n    if (path.key === key && parent.get(key) === path) {\n      return findActionForNode(parent);\n    }\n  }\n\n  return ['remove', path];\n}\n\n// @babel/preset-typescript transpiles enums, but doesn't reference used identifiers.\nfunction referenceEnums(program: NodePath<Program>) {\n  console.log(\"scopeHelpers - referenceEnums\");\n  /*\n   * We are looking for transpiled enums.\n   *   (function (Colors) {\n   *     Colors[\"BLUE\"] = \"#27509A\";\n   *   })(Colors || (Colors = {}));\n   */\n  program.traverse({\n    ExpressionStatement(expressionStatement) {\n      const expression = expressionStatement.get('expression');\n      if (!expression.isCallExpression()) return;\n\n      const callee = expression.get('callee');\n      const args = expression.get('arguments');\n      if (!callee.isFunctionExpression() || args.length !== 1) return;\n      const [arg] = args;\n      if (arg.isLogicalExpression({ operator: '||' })) {\n        referenceAll(arg);\n      }\n    },\n  });\n}\n\nconst fixed = new WeakSet<NodePath<Program>>();\n\nfunction removeUnreferenced(items: NodePath<Identifier | JSXIdentifier>[]) {\n  console.log(\"scopeHelpers - removeUnreferenced\");\n  const referenced = new Set<NodePath<Identifier | JSXIdentifier>>();\n  items.forEach((item) => {\n    if (!item.node || isRemoved(item)) return;\n    const binding = getScope(item).getBinding(item.node.name);\n    if (!binding) return;\n    const hasReferences =\n      binding.referencePaths.filter((i) => !isRemoved(i)).length > 0;\n    if (hasReferences) {\n      referenced.add(item);\n      return;\n    }\n\n    const forDeleting = [binding.path, ...binding.constantViolations]\n      .map(findActionForNode)\n      .filter(isNotNull)\n      .map(getPathFromAction);\n\n    if (forDeleting.length === 0) return;\n\n    findIdentifiers(forDeleting).forEach((identifier) => {\n      referenced.add(identifier);\n    });\n\n    removeWithRelated(forDeleting);\n  });\n\n  const result = [...referenced];\n  result.sort((a, b) => a.node?.name.localeCompare(b.node?.name));\n\n  return result;\n}\n\nfunction getNodeForValue(value: unknown): Node | undefined {\n  console.log(\"scopeHelpers - getNodeForValue\");\n  if (typeof value === 'string') {\n    return {\n      type: 'StringLiteral',\n      value,\n    };\n  }\n\n  if (typeof value === 'number') {\n    return {\n      type: 'NumericLiteral',\n      value,\n    };\n  }\n\n  if (typeof value === 'boolean') {\n    return {\n      type: 'BooleanLiteral',\n      value,\n    };\n  }\n\n  if (value === null) {\n    return {\n      type: 'NullLiteral',\n    };\n  }\n\n  if (value === undefined) {\n    return {\n      type: 'Identifier',\n      name: 'undefined',\n    };\n  }\n\n  return undefined;\n}\n\nfunction staticEvaluate(path: NodePath | null | undefined): void {\n  console.log(\"scopeHelpers - staticEvaluate\");\n  if (!path) return;\n  const evaluated = path.evaluate();\n  if (evaluated.confident) {\n    const node = getNodeForValue(evaluated.value);\n    if (node) {\n      applyAction(['replace', path, node]);\n      return;\n    }\n  }\n\n  if (path.isIfStatement()) {\n    const test = path.get('test');\n    if (!test.isBooleanLiteral()) {\n      return;\n    }\n\n    const { consequent, alternate } = path.node;\n    if (test.node.value) {\n      applyAction(['replace', path, consequent]);\n    } else if (alternate) {\n      applyAction(['replace', path, alternate]);\n    } else {\n      applyAction(['remove', path]);\n    }\n  }\n}\n\nfunction applyAction(action: ReplaceAction | RemoveAction) {\n  console.log(\"scopeHelpers - applyAction\");\n  mutate(action[1], (p) => {\n    if (isRemoved(p)) return;\n\n    const parent = p.parentPath;\n\n    if (action[0] === 'remove') {\n      p.remove();\n    }\n\n    if (action[0] === 'replace') {\n      p.replaceWith(action[2]);\n    }\n\n    staticEvaluate(parent);\n  });\n}\n\nfunction removeWithRelated(paths: NodePath[]) {\n  console.log(\"scopeHelpers - removeWithRelated\");\n  if (paths.length === 0) return;\n\n  const rootPath = getScope(paths[0]).getProgramParent()\n    .path as NodePath<Program>;\n\n  if (!fixed.has(rootPath)) {\n    // Some libraries don't care about bindings, references, and other staff\n    // So we have to fix the scope before we can detect unused code\n    referenceEnums(rootPath);\n    fixed.add(rootPath);\n  }\n\n  const actions: (ReplaceAction | RemoveAction)[] = paths\n    .map(findActionForNode)\n    .filter(isNotNull);\n\n  const affectedPaths = actions.map(getPathFromAction);\n\n  let referencedIdentifiers = findIdentifiers(affectedPaths, 'reference');\n  referencedIdentifiers.sort(\n    (a, b) => a.node?.name.localeCompare(b.node?.name)\n  );\n\n  const referencesOfBinding = findIdentifiers(affectedPaths, 'declaration')\n    .map((i) => (i.node && getScope(i).getBinding(i.node.name)) ?? null)\n    .filter(isNotNull)\n    .reduce(\n      (acc, i) => [...acc, ...i.referencePaths.filter(nonType)],\n      [] as NodePath[]\n    )\n    .filter(\n      (ref) =>\n        // Do not remove `export default function`\n        !ref.isExportDefaultDeclaration() ||\n        !ref.get('declaration').isFunctionDeclaration()\n    );\n\n  actions.forEach(applyAction);\n\n  removeWithRelated(referencesOfBinding);\n\n  let clean = false;\n  while (!clean && referencedIdentifiers.length > 0) {\n    const referenced = removeUnreferenced(referencedIdentifiers);\n    clean =\n      referenced.map((i) => i.node?.name).join('|') ===\n      referencedIdentifiers.map((i) => i.node?.name).join('|');\n    referencedIdentifiers = referenced;\n  }\n}\n\nfunction mutate<T extends NodePath>(path: T, fn: (p: T) => NodePath[] | void) {\n  console.log(\"scopeHelpers - mutate\");\n  const dereferenced = dereferenceAll(path);\n\n  const mutated = fn(path);\n\n  referenceAll(path);\n  mutated?.forEach((p) => referenceAll(p));\n\n  const dead = dereferenced.filter((p) => !isReferenced(p));\n\n  const forDeleting: NodePath[] = [];\n  dead.forEach((binding) => {\n    const assignments = [binding.path, ...binding.constantViolations];\n    assignments.forEach((assignment) => {\n      const { scope } = assignment;\n      const declared = Object.values(\n        assignment.getOuterBindingIdentifiers(false)\n      );\n      if (\n        declared.length === 1 &&\n        'name' in declared[0] &&\n        declared[0].name === binding.identifier.name\n      ) {\n        const init = assignment.get('init');\n        if (!Array.isArray(init) && init?.isAssignmentExpression()) {\n          // `const a = b = 1` â†’ `b = 1`\n          assignment.parentPath?.replaceWith({\n            type: 'ExpressionStatement',\n            expression: init.node,\n          });\n\n          const left = init.get('left');\n          if (left.isIdentifier()) {\n            // If it was forcefully referenced in the shaker\n            dereference(left);\n          }\n\n          return;\n        }\n        // Only one identifier is declared, so we can remove the whole declaration\n        forDeleting.push(assignment);\n        return;\n      }\n\n      if (\n        declared.every(\n          (identifier) =>\n            identifier.type === 'Identifier' &&\n            !scope.getBinding(identifier.name)?.referenced\n        )\n      ) {\n        // No other identifier is referenced, so we can remove the whole declaration\n        forDeleting.push(assignment);\n        return;\n      }\n\n      // We can't remove the binding, but we can remove the part of it\n      assignment.traverse({\n        Identifier(identifier) {\n          if (identifier.node.name === binding.identifier.name) {\n            const parent = identifier.parentPath;\n            if (\n              parent.isArrayPattern() &&\n              identifier.listKey === 'elements' &&\n              typeof identifier.key === 'number'\n            ) {\n              parent.node.elements[identifier.key] = null;\n            } else if (parent.isObjectProperty()) {\n              forDeleting.push(parent);\n            }\n          }\n        },\n      });\n    });\n  });\n\n  removeWithRelated(forDeleting);\n}\n\nexport { applyAction, mutate, removeWithRelated };\n"],"mappings":"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","ignoreList":[]}