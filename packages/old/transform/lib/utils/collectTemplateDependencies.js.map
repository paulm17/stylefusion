{"version":3,"file":"collectTemplateDependencies.js","names":["_template","require","_types","_shared","_createId","_findIdentifiers","_getSource","_scopeHelpers","_valueToLiteral","staticEval","ex","evaluate","console","log","undefined","result","confident","hasEvalMeta","value","expressionDeclarationTpl","statement","preserveComments","unsupported","reason","buildCodeFrameError","isIdentifier","getUidInRootScope","path","name","node","rootScope","scope","getProgramParent","hasBinding","generateUid","hoistVariableDeclarator","parent","referencedIdentifiers","findIdentifiers","forEach","identifier","hoistIdentifier","bindingIdentifiers","newName","rename","statementInRoot","findParent","p","_p$parentPath","parentPath","isProgram","declaration","type","kind","declarations","cloneNode","inserted","insertBefore","referenceAll","registerDeclaration","idPath","isReferenced","binding","getBinding","includes","bindingPath","isVariableDeclarator","extractExpression","imports","isLiteral","ValueType","CONST","loc","_p$parentPath2","isFunction","isFunctionExpression","isArrowFunctionExpression","expUid","evaluated","id","evaluatedId","mutate","replaceWith","valueToLiteral","FUNCTION","LAZY","expId","createId","expression","importedFrom","findImportSourceOfIdentifier","_idPath$scope$getBind","_imports$find","exBindingIdentifier","exImport","find","i","local","push","source","traverse","Identifier","callee","arguments","debug","logger","extend","collectTemplateDependencies","quasi","get","quasis","expressions","length","expressionValues","map","bind","getSource","isExpression","extracted"],"sources":["../../src/utils/collectTemplateDependencies.ts"],"sourcesContent":["/* eslint @typescript-eslint/no-use-before-define: [\"error\", { \"functions\": false }] */\n\n/**\n * This file is a visitor that checks TaggedTemplateExpressions and look for WYW template literals.\n * For each template it makes a list of dependencies, try to evaluate expressions, and if it is not possible, mark them as lazy dependencies.\n */\n\nimport { statement } from '@babel/template';\nimport type { NodePath } from '@babel/traverse';\nimport type {\n  Expression,\n  Identifier,\n  JSXIdentifier,\n  Statement,\n  TaggedTemplateExpression,\n  TemplateElement,\n  TSType,\n  VariableDeclaration,\n  VariableDeclarator,\n} from '@babel/types';\nimport { cloneNode } from '@babel/types';\n\nimport type {\n  ConstValue,\n  ExpressionValue,\n  FunctionValue,\n  LazyValue,\n} from '@wyw-in-js/shared';\nimport { hasEvalMeta, ValueType, logger } from '@wyw-in-js/shared';\n\nimport type { IImport } from './collectExportsAndImports';\nimport { createId } from './createId';\nimport { findIdentifiers } from './findIdentifiers';\nimport { getSource } from './getSource';\nimport { mutate, referenceAll } from './scopeHelpers';\nimport { valueToLiteral } from './valueToLiteral';\n\nfunction staticEval(\n  ex: NodePath<Expression>,\n  evaluate = false\n): [unknown] | undefined {\n  console.log(\"collectTemplateDependencies - staticEval\");\n  if (!evaluate) return undefined;\n\n  const result = ex.evaluate();\n  if (result.confident && !hasEvalMeta(result.value)) {\n    return [result.value];\n  }\n\n  return undefined;\n}\n\nconst expressionDeclarationTpl = statement(\n  'const %%expId%% = /*#__PURE__*/ () => %%expression%%',\n  {\n    preserveComments: true,\n  }\n);\n\nconst unsupported = (ex: NodePath, reason?: string): Error =>\n  ex.buildCodeFrameError(\n    `This ${\n      ex.isIdentifier() ? 'identifier' : 'expression'\n    } cannot be used in the template${reason ? `, because it ${reason}` : ''}.`\n  );\n\nfunction getUidInRootScope(path: NodePath<Identifier | JSXIdentifier>): string {\n  console.log(\"collectTemplateDependencies - getUidInRootScope\");\n  const { name } = path.node;\n  const rootScope = path.scope.getProgramParent();\n  if (rootScope.hasBinding(name)) {\n    return rootScope.generateUid(name);\n  }\n\n  return name;\n}\n\nfunction hoistVariableDeclarator(ex: NodePath<VariableDeclarator>) {\n  console.log(\"collectTemplateDependencies - hoistVariableDeclarator\");\n  if (!ex.scope.parent) {\n    // It is already in the root scope\n    return;\n  }\n\n  const referencedIdentifiers = findIdentifiers([ex], 'reference');\n  referencedIdentifiers.forEach((identifier) => {\n    if (identifier.isIdentifier()) {\n      hoistIdentifier(identifier);\n    }\n  });\n\n  const bindingIdentifiers = findIdentifiers([ex], 'declaration');\n\n  bindingIdentifiers.forEach((path) => {\n    const newName = getUidInRootScope(path);\n    if (newName !== path.node.name) {\n      path.scope.rename(path.node.name, newName);\n    }\n  });\n\n  const rootScope = ex.scope.getProgramParent();\n\n  const statementInRoot = ex.findParent(\n    (p) => p.parentPath?.isProgram() === true\n  ) as NodePath<Statement>;\n\n  const declaration: VariableDeclaration = {\n    type: 'VariableDeclaration',\n    kind: 'let',\n    declarations: [cloneNode(ex.node)],\n  };\n\n  const [inserted] = statementInRoot.insertBefore(declaration);\n  referenceAll(inserted);\n  rootScope.registerDeclaration(inserted);\n}\n\nfunction hoistIdentifier(idPath: NodePath<Identifier>): void {\n  console.log(\"collectTemplateDependencies - hoistIdentifier\");\n  if (!idPath.isReferenced()) {\n    throw unsupported(idPath);\n  }\n\n  const binding = idPath.scope.getBinding(idPath.node.name);\n  if (!binding) {\n    // It's something strange\n    throw unsupported(idPath, 'is undefined');\n  }\n\n  if (binding.kind === 'module') {\n    // Modules are global by default\n    return;\n  }\n\n  if (!['var', 'let', 'const', 'hoisted'].includes(binding.kind)) {\n    // This is not a variable, we can't hoist it\n    throw unsupported(binding.path, 'is a function parameter');\n  }\n\n  const { scope, path: bindingPath } = binding;\n  // parent here can be null or undefined in different versions of babel\n  if (!scope.parent) {\n    // The variable is already in the root scope\n    return;\n  }\n\n  if (bindingPath.isVariableDeclarator()) {\n    hoistVariableDeclarator(bindingPath);\n\n    return;\n  }\n\n  throw unsupported(idPath);\n}\n\n/**\n * Only an expression that can be evaluated in the root scope can be\n * used in a WYW template. This function tries to hoist the expression.\n * @param ex The expression to hoist.\n * @param evaluate If true, we try to statically evaluate the expression.\n * @param imports All the imports of the file.\n */\nexport function extractExpression(\n  ex: NodePath<Expression>,\n  evaluate = false,\n  imports: IImport[] = []\n): Omit<ExpressionValue, 'buildCodeFrameError' | 'source'> {\n  console.log(\"collectTemplateDependencies - extractExpression\");\n  if (\n    ex.isLiteral() &&\n    ('value' in ex.node || ex.node.type === 'NullLiteral')\n  ) {\n    return {\n      ex: ex.node,\n      kind: ValueType.CONST,\n      value: ex.node.type === 'NullLiteral' ? null : ex.node.value,\n    } as Omit<ConstValue, 'buildCodeFrameError' | 'source'>;\n  }\n\n  const { loc } = ex.node;\n\n  const rootScope = ex.scope.getProgramParent();\n  const statementInRoot = ex.findParent(\n    (p) => p.parentPath?.isProgram() === true\n  ) as NodePath<Statement>;\n\n  const isFunction =\n    ex.isFunctionExpression() || ex.isArrowFunctionExpression();\n\n  // Generate next _expN name\n  const expUid = rootScope.generateUid('exp');\n\n  const evaluated = staticEval(ex, evaluate);\n\n  if (!evaluated) {\n    // If expression is not statically evaluable,\n    // we need to hoist all its referenced identifiers\n\n    // Collect all referenced identifiers\n    findIdentifiers([ex], 'reference').forEach((id) => {\n      if (!id.isIdentifier()) return;\n\n      // Try to evaluate and inline them…\n      const evaluatedId = staticEval(id, evaluate);\n      if (evaluatedId) {\n        mutate(id, (p) => {\n          p.replaceWith(valueToLiteral(evaluatedId[0], ex));\n        });\n      } else {\n        // … or hoist them to the root scope\n        hoistIdentifier(id);\n      }\n    });\n  }\n\n  const kind = isFunction ? ValueType.FUNCTION : ValueType.LAZY;\n\n  // Declare _expN const with the lazy expression\n  const declaration = expressionDeclarationTpl({\n    expId: createId(expUid),\n    expression: evaluated\n      ? valueToLiteral(evaluated[0], ex)\n      : cloneNode(ex.node),\n  }) as VariableDeclaration;\n\n  // Insert the declaration as close as possible to the original expression\n  const [inserted] = statementInRoot.insertBefore(declaration);\n  referenceAll(inserted);\n  rootScope.registerDeclaration(inserted);\n\n  const importedFrom: string[] = [];\n  function findImportSourceOfIdentifier(idPath: NodePath<Identifier>) {\n    console.log(\"collectTemplateDependencies - findImportSourceOfIdentifier\");\n    const exBindingIdentifier = idPath.scope.getBinding(idPath.node.name)\n      ?.identifier;\n    const exImport =\n      imports.find((i) => i.local.node === exBindingIdentifier) ?? null;\n    if (exImport) {\n      importedFrom.push(exImport.source);\n    }\n  }\n\n  if (ex.isIdentifier()) {\n    findImportSourceOfIdentifier(ex);\n  } else {\n    ex.traverse({\n      Identifier: findImportSourceOfIdentifier,\n    });\n  }\n\n  // Replace the expression with the _expN() call\n  mutate(ex, (p) => {\n    p.replaceWith({\n      type: 'CallExpression',\n      callee: createId(expUid),\n      arguments: [],\n    });\n  });\n\n  // eslint-disable-next-line no-param-reassign\n  ex.node.loc = loc;\n\n  // noinspection UnnecessaryLocalVariableJS\n  const result: Omit<\n    LazyValue | FunctionValue,\n    'buildCodeFrameError' | 'source'\n  > = {\n    kind,\n    ex: createId(expUid, loc),\n    importedFrom,\n  };\n\n  return result;\n}\n\nconst debug = logger.extend('template-parse:identify-expressions');\n\n/**\n * Collects, hoists, and makes lazy all expressions in the given template\n * If evaluate is true, it will try to evaluate the expressions\n */\nexport function collectTemplateDependencies(\n  path: NodePath<TaggedTemplateExpression>,\n  evaluate = false\n): [quasis: TemplateElement[], expressionValues: ExpressionValue[]] {\n  console.log(\"collectTemplateDependencies - collectTemplateDependencies\");\n  const quasi = path.get('quasi');\n  const quasis = quasi.get('quasis');\n  const expressions = quasi.get('expressions');\n\n  debug('Found: %s', expressions.length);\n\n  const expressionValues: ExpressionValue[] = expressions.map(\n    (ex: NodePath<Expression | TSType>): ExpressionValue => {\n      const buildCodeFrameError = ex.buildCodeFrameError.bind(ex);\n      const source = getSource(ex);\n\n      if (!ex.isExpression()) {\n        throw buildCodeFrameError(\n          `The expression '${source}' is not supported.`\n        );\n      }\n\n      const extracted = extractExpression(ex, evaluate);\n\n      return {\n        ...extracted,\n        source,\n        buildCodeFrameError,\n      } as ExpressionValue;\n    }\n  );\n\n  return [quasis.map((p) => p.node), expressionValues];\n}\n"],"mappings":"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","ignoreList":[]}