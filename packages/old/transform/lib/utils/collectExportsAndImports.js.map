{"version":3,"file":"collectExportsAndImports.js","names":["_shared","require","_getScope","_isExports","_isNotNull","_isRequire","_isTypedNode","_traversalCache","sideEffectImport","item","imported","exports","explicitImport","getValue","node","console","log","type","name","value","isType","p","importKind","exportKind","collectors","ImportSpecifier","path","source","get","local","ImportDefaultSpecifier","ImportNamespaceSpecifier","unfoldNamespaceImport","collectFromImportDeclaration","state","specifiers","length","imports","push","forEach","specifier","isImportSpecifier","collector","getAncestorsWhile","cond","result","current","parentPath","whatIsDestructed","objectPattern","destructedProps","traverse","Identifier","identifier","isBindingIdentifier","parent","isObjectProperty","chain","filter","isTypedNode","map","key","isIdentifier","isNotNull","reverse","what","as","isRestElement","argument","debug","logger","extend","importFromVariableDeclarator","isSync","id","isObjectPattern","findIIFE","isCallExpression","isFunctionExpression","exportFromVariableDeclarator","init","binding","getScope","getBinding","iife","referencePaths","constantViolations","find","isExpression","reduce","acc","destructed","collectFromDynamicImport","callExpression","sourcePath","isStringLiteral","container","isAwaited","isAwaitExpression","isVariableDeclarator","prop","getCalleeName","callee","isMemberExpression","property","undefined","matchCall","rules","some","n","args","fnArgs","every","arg","i","getImportExportTypeByInteropFunction","argPath","isExports","isEmptyObject","isArrayExpression","isAlreadyProcessed","isRequireCall","isRequire","isObjectExpression","properties","pathOrName","collectFromRequire","processedRequires","has","add","reexports","exported","variableDeclarator","unfolded","isExpressionStatement","collectFromVariableDeclarator","found","identifierPath","skip","isChainOfVoidAssignment","right","isUnaryExpression","operator","isAssignmentExpression","getReturnValue","params","body","_body$get","returnStatement","isReturnStatement","getGetterValueFromDescriptor","descriptor","props","getter","isArrowFunctionExpression","valueProp","valueValue","addExport","getRelatedImport","object","objectBinding","scope","isAncestor","computed","import","relatedImport","saveRef","exportName","memberExpression","exportRefs","set","collectFromExports","assignmentExpression","left","isEsModule","matchesPattern","obj","collectFromRequireOrExports","importItem","referenced","referencePath","_binding$referencePat","ancestor","isTSType","isFlowType","listKey","importType","isExportSpecifier","isExportDefaultDeclaration","collectFromExportAllDeclaration","_path$get","collectFromExportSpecifier","isExportDefaultSpecifier","isExportNamespaceSpecifier","collectFromExportNamedDeclaration","_path$get2","declaration","isVariableDeclaration","declarator","isTSEnumDeclaration","isFunctionDeclaration","isClassDeclaration","collectFromExportDefaultDeclaration","default","collectFromAssignmentExpression","_right$get","isExportRef","imp","collectAllFromCall","_requireCall$get","requireCall","collectFromMap","isFunction","returnValue","collectMapFromCall","mapPosition","collectFromEsbuildReExportCall","_requireCall$get2","sourceExports","someCall","firstArg","collectFromCallExpression","maybeExportStart","secondArg","collectExportsAndImports","cacheMode","localState","deadExports","Map","sourceType","WeakSet","cache","getTraversalCache","_cache$get","AssignmentExpression","CallExpression","ExportAllDeclaration","ExportDefaultDeclaration","ExportNamedDeclaration","ImportDeclaration","Import","VariableDeclarator"],"sources":["../../src/utils/collectExportsAndImports.ts"],"sourcesContent":["/* eslint @typescript-eslint/no-use-before-define: [\"error\", { \"functions\": false }] */\n/* eslint-disable no-restricted-syntax,no-continue */\n\nimport type { NodePath } from '@babel/traverse';\nimport type {\n  ArrayExpression,\n  AssignmentExpression,\n  BlockStatement,\n  CallExpression,\n  ExportAllDeclaration,\n  ExportDefaultDeclaration,\n  ExportDefaultSpecifier,\n  ExportNamedDeclaration,\n  ExportNamespaceSpecifier,\n  ExportSpecifier,\n  Expression,\n  Function as FunctionNode,\n  Identifier,\n  Import,\n  ImportDeclaration,\n  ImportDefaultSpecifier,\n  ImportNamespaceSpecifier,\n  ImportSpecifier,\n  MemberExpression,\n  ObjectExpression,\n  ObjectPattern,\n  Program,\n  StringLiteral,\n  VariableDeclarator,\n} from '@babel/types';\n\nimport { logger } from '@wyw-in-js/shared';\n\nimport { getScope } from './getScope';\nimport { isExports } from './isExports';\nimport { isNotNull } from './isNotNull';\nimport { isRequire } from './isRequire';\nimport { isTypedNode } from './isTypedNode';\nimport { getTraversalCache } from './traversalCache';\n\nexport interface ISideEffectImport {\n  imported: 'side-effect';\n  local: NodePath;\n  source: string;\n}\n\nexport interface IImport {\n  imported: string | 'default' | '*';\n  local: NodePath<Identifier | MemberExpression>;\n  source: string;\n  type: 'cjs' | 'dynamic' | 'esm';\n}\n\nexport type Exports = Record<string | 'default' | '*', NodePath>; // '*' means re-export all\n\nexport interface IReexport {\n  exported: string | 'default' | '*';\n  imported: string | 'default' | '*';\n  local: NodePath;\n  source: string;\n}\n\nexport interface IState {\n  deadExports: string[];\n  exportRefs: Map<string, NodePath<MemberExpression>[]>;\n  exports: Exports;\n  imports: (IImport | ISideEffectImport)[];\n  isEsModule: boolean;\n  reexports: IReexport[];\n}\n\ninterface ILocalState extends IState {\n  processedRequires: WeakSet<NodePath>;\n}\n\nexport const sideEffectImport = (\n  item: IImport | ISideEffectImport\n): item is ISideEffectImport => item.imported === 'side-effect';\n\nexport const explicitImport = (\n  item: IImport | ISideEffectImport\n): item is IImport => item.imported !== 'side-effect';\n\nfunction getValue({ node }: { node: Identifier | StringLiteral }): string {\n  console.log(\"collectExportsAndImports - getValue\");\n  return node.type === 'Identifier' ? node.name : node.value;\n}\n\n// We ignore imports and exports of types\nconst isType = (p: {\n  node: { importKind?: 'type' | unknown } | { exportKind?: 'type' | unknown };\n}): boolean =>\n  ('importKind' in p.node && p.node.importKind === 'type') ||\n  ('exportKind' in p.node && p.node.exportKind === 'type');\n\n// Force TypeScript to check, that we have implementation for every possible specifier\ntype SpecifierTypes = ImportDeclaration['specifiers'][number];\nconst collectors: {\n  [K in SpecifierTypes['type']]: (\n    path: NodePath<SpecifierTypes & { type: K }>,\n    source: string\n  ) => IImport[];\n} = {\n  ImportSpecifier(path: NodePath<ImportSpecifier>, source): IImport[] {\n    if (isType(path)) return [];\n    const imported = getValue(path.get('imported'));\n    const local = path.get('local');\n    return [{ imported, local, source, type: 'esm' }];\n  },\n\n  ImportDefaultSpecifier(\n    path: NodePath<ImportDefaultSpecifier>,\n    source\n  ): IImport[] {\n    const local = path.get('local');\n    return [{ imported: 'default', local, source, type: 'esm' }];\n  },\n\n  ImportNamespaceSpecifier(\n    path: NodePath<ImportNamespaceSpecifier>,\n    source\n  ): IImport[] {\n    const local = path.get('local');\n    return unfoldNamespaceImport({ imported: '*', local, source, type: 'esm' });\n  },\n};\n\nfunction collectFromImportDeclaration(\n  path: NodePath<ImportDeclaration>,\n  state: ILocalState\n): void {\n  console.log(\"collectExportsAndImports - collectFromImportDeclaration\");\n  // If importKind is specified, and it's not a value, ignore that import\n  if (isType(path)) return;\n\n  const source = getValue(path.get('source'));\n  const specifiers = path.get('specifiers');\n\n  if (specifiers.length === 0) {\n    state.imports.push({ imported: 'side-effect', local: path, source });\n  }\n\n  specifiers.forEach(<T extends SpecifierTypes>(specifier: NodePath<T>) => {\n    if (specifier.isImportSpecifier() && isType(specifier)) return;\n\n    const collector = collectors[\n      specifier.node.type\n    ] as (typeof collectors)[T['type']];\n\n    state.imports.push(...collector(specifier, source));\n  });\n}\n\ninterface IDestructed {\n  as: NodePath<Identifier>;\n  what: string | '*';\n}\n\nfunction getAncestorsWhile(path: NodePath, cond: (p: NodePath) => boolean) {\n  console.log(\"collectExportsAndImports - getAncestorsWhile\");\n  const result: NodePath[] = [];\n  let current: NodePath | null = path;\n  while (current && cond(current)) {\n    result.push(current);\n    current = current.parentPath;\n  }\n\n  return result;\n}\n\nfunction whatIsDestructed(\n  objectPattern: NodePath<ObjectPattern>\n): IDestructed[] {\n  console.log(\"collectExportsAndImports - whatIsDestructed\");\n  const destructedProps: IDestructed[] = [];\n  objectPattern.traverse({\n    Identifier(identifier) {\n      if (identifier.isBindingIdentifier()) {\n        const parent = identifier.parentPath;\n        if (parent.isObjectProperty({ value: identifier.node })) {\n          const chain = getAncestorsWhile(parent, (p) => p !== objectPattern)\n            .filter(isTypedNode('ObjectProperty'))\n            .map((p) => {\n              const key = p.get('key');\n              if (!key.isIdentifier()) {\n                // TODO: try to process other type of keys or at least warn about this\n                return null;\n              }\n\n              return key;\n            })\n            .filter(isNotNull);\n          chain.reverse();\n\n          if (chain.length > 0) {\n            destructedProps.push({\n              what: chain[0].node.name,\n              as: identifier,\n            });\n          }\n\n          return;\n        }\n\n        if (parent.isRestElement({ argument: identifier.node })) {\n          destructedProps.push({\n            what: '*',\n            as: identifier,\n          });\n        }\n      }\n    },\n  });\n\n  return destructedProps;\n}\n\nconst debug = logger.extend('evaluator:collectExportsAndImports');\n\nfunction importFromVariableDeclarator(\n  path: NodePath<VariableDeclarator>,\n  isSync: boolean\n): IDestructed[] {\n  console.log(\"collectExportsAndImports - importFromVariableDeclarator\");\n  const id = path.get('id');\n  if (id.isIdentifier()) {\n    // It's the simplest case when the full namespace is imported\n    return [\n      {\n        as: id,\n        what: '*',\n      },\n    ];\n  }\n\n  if (!isSync) {\n    // Something went wrong\n    // Is it something like `const { … } = import(…)`?\n    debug('`import` should be awaited');\n    return [];\n  }\n\n  if (id.isObjectPattern()) {\n    return whatIsDestructed(id);\n  }\n\n  // What else it can be?\n  debug('importFromVariableDeclarator: unknown type of id %o', id.node.type);\n\n  return [];\n}\n\nconst findIIFE = (path: NodePath): NodePath<CallExpression> | null => {\n  console.log(\"collectExportsAndImports - findIIFE\");\n  if (path.isCallExpression() && path.get('callee').isFunctionExpression()) {\n    return path;\n  }\n\n  if (!path.parentPath) {\n    return null;\n  }\n\n  return findIIFE(path.parentPath);\n};\n\nfunction exportFromVariableDeclarator(\n  path: NodePath<VariableDeclarator>\n): Exports {\n  console.log(\"collectExportsAndImports - exportFromVariableDeclarator\");\n  const id = path.get('id');\n  const init = path.get('init');\n\n  // If there is no init and id is an identifier, we should find IIFE\n  if (!init.node && id.isIdentifier()) {\n    const binding = getScope(path).getBinding(id.node.name);\n    if (!binding) {\n      return {};\n    }\n\n    const iife = [\n      ...binding.referencePaths,\n      ...binding.constantViolations,\n      binding.path,\n    ]\n      .map(findIIFE)\n      .find(isNotNull);\n\n    if (!iife) {\n      return {};\n    }\n\n    return {\n      [id.node.name]: iife,\n    };\n  }\n\n  if (!init || !init.isExpression()) {\n    return {};\n  }\n\n  if (id.isIdentifier()) {\n    // It is `export const a = 1;`\n    return {\n      [id.node.name]: init,\n    };\n  }\n\n  if (id.isObjectPattern()) {\n    // It is `export const { a, ...rest } = obj;`\n    return whatIsDestructed(id).reduce<Exports>(\n      (acc, destructed) => ({\n        ...acc,\n        [destructed.as.node.name]: init,\n      }),\n      {}\n    );\n  }\n\n  // What else it can be?\n  debug('exportFromVariableDeclarator: unknown type of id %o', id.node.type);\n\n  return {};\n}\n\nfunction collectFromDynamicImport(\n  path: NodePath<Import>,\n  state: ILocalState\n): void {\n  console.log(\"collectExportsAndImports - collectFromDynamicImport\");\n  const { parentPath: callExpression } = path;\n  if (!callExpression.isCallExpression()) {\n    // It's wrong `import`\n    return;\n  }\n\n  const [sourcePath] = callExpression.get('arguments');\n  if (!sourcePath || !sourcePath.isStringLiteral()) {\n    // Import should have at least one argument, and it should be StringLiteral\n    return;\n  }\n\n  const source = sourcePath.node.value;\n\n  let { parentPath: container, key } = callExpression;\n  let isAwaited = false;\n\n  if (container.isAwaitExpression()) {\n    // If it's not awaited import, it imports the full namespace\n    isAwaited = true;\n    key = container.key;\n    container = container.parentPath!;\n  }\n\n  // Is it `const something = await import(\"something\")`?\n  if (key === 'init' && container.isVariableDeclarator()) {\n    importFromVariableDeclarator(container, isAwaited).map((prop) =>\n      state.imports.push({\n        imported: prop.what,\n        local: prop.as,\n        source,\n        type: 'dynamic',\n      })\n    );\n  }\n}\n\nfunction getCalleeName(path: NodePath<CallExpression>): string | undefined {\n  console.log(\"collectExportsAndImports - getCalleeName\");\n  const callee = path.get('callee');\n  if (callee.isIdentifier()) {\n    return callee.node.name;\n  }\n\n  if (callee.isMemberExpression()) {\n    const property = callee.get('property');\n    if (property.isIdentifier()) {\n      return property.node.name;\n    }\n  }\n\n  return undefined;\n}\n\ntype MatchRule = [\n  name: string,\n  ...args: (NodePath | '*' | ((p: NodePath) => boolean))[],\n];\n\nconst matchCall = (p: NodePath<CallExpression>, rules: MatchRule[]) => {\n  console.log(\"collectExportsAndImports - matchCall\");\n  const name = getCalleeName(p);\n\n  if (name === undefined) {\n    return false;\n  }\n\n  return rules.some(([n, ...args]) => {\n    if (name !== n) return false;\n    const fnArgs = p.get('arguments');\n    if (fnArgs.length !== args.length) return false;\n    return args.every((arg, i) => {\n      if (arg === '*') return true;\n      if (typeof arg === 'function') return arg(fnArgs[i]);\n      return arg === fnArgs[i];\n    });\n  });\n};\n\nfunction getImportExportTypeByInteropFunction(\n  path: NodePath<CallExpression>,\n  argPath: NodePath\n): 'import:*' | 're-export:*' | 'default' | undefined {\n  console.log(\"collectExportsAndImports - getImportExportTypeByInteropFunction\");\n  if (matchCall(path, [['__exportStar', argPath, (p) => isExports(p)]])) {\n    return 're-export:*';\n  }\n\n  if (\n    matchCall(path, [\n      ['_interopRequireDefault', argPath], // babel and swc <1.3.50\n      ['_interop_require_default', argPath], // swc >=1.3.50\n      ['__importDefault', argPath], // ?\n    ])\n  ) {\n    return 'default';\n  }\n\n  if (\n    matchCall(path, [\n      ['_interopRequireWildcard', argPath], // babel and swc <1.3.50\n      ['_interop_require_wildcard', argPath], // swc >=1.3.50\n      ['__importStar', argPath], // ?\n      ['__toESM', argPath], // esbuild >=0.14.7\n      ['__toModule', argPath], // esbuild <0.14.7\n    ])\n  ) {\n    return 'import:*';\n  }\n\n  if (\n    matchCall(path, [\n      ['_extends', isEmptyObject, argPath], // babel and swc\n      ['__rest', argPath, isArrayExpression], // tsc and esbuild <=0.11.3\n      ['__objRest', argPath, isArrayExpression], // esbuild >0.11.3\n      ['_objectWithoutProperties', argPath, isArrayExpression], // babel and swc <1.3.50\n      ['_object_without_properties', argPath, isArrayExpression], // swc >=1.3.50\n      ['_objectDestructuringEmpty', argPath], // swc <1.3.50\n      ['_object_destructuring_empty', argPath], // swc >=1.3.50\n    ])\n  ) {\n    return 'import:*';\n  }\n\n  return undefined;\n}\n\nfunction isAlreadyProcessed(path: NodePath): boolean {\n  console.log(\"collectExportsAndImports - isAlreadyProcessed\");\n  if (\n    path.isCallExpression() &&\n    path.get('callee').isIdentifier({ name: '__toCommonJS' })\n  ) {\n    // because its esbuild and we already processed all exports\n    return true;\n  }\n\n  return false;\n}\n\nfunction isRequireCall(path: NodePath): path is NodePath<CallExpression> {\n  console.log(\"collectExportsAndImports - isRequireCall\");\n  return path.isCallExpression() && isRequire(path.get('callee'));\n}\n\nfunction isEmptyObject(path: NodePath): path is NodePath<ObjectExpression> {\n  console.log(\"collectExportsAndImports - isEmptyObject\");\n  return path.isObjectExpression() && path.node.properties.length === 0;\n}\n\nfunction isArrayExpression(path: NodePath): path is NodePath<ArrayExpression> {\n  console.log(\"collectExportsAndImports - isArrayExpression\");\n  return path.isArrayExpression();\n}\n\nfunction isCallExpression(path: NodePath): path is NodePath<CallExpression>;\nfunction isCallExpression(\n  calleeName: string\n): (path: NodePath) => path is NodePath<CallExpression>;\nfunction isCallExpression(pathOrName: NodePath | string) {\n  console.log(\"collectExportsAndImports - isCallExpression\");\n  if (typeof pathOrName === 'string') {\n    return (p: NodePath) =>\n      p.isCallExpression() &&\n      p.get('callee').isIdentifier({ name: pathOrName });\n  }\n\n  return pathOrName.isCallExpression();\n}\n\nfunction isObjectExpression(\n  path: NodePath\n): path is NodePath<ObjectExpression> {\n  console.log(\"collectExportsAndImports - isObjectExpression\");\n  return path.isObjectExpression();\n}\n\nfunction isIdentifier(name: string) {\n  console.log(\"collectExportsAndImports - isIdentifier\");\n  return (path: NodePath): path is NodePath<Identifier> =>\n    path.isIdentifier({ name });\n}\n\nfunction collectFromRequire(\n  path: NodePath<Identifier>,\n  state: ILocalState\n): void {\n  console.log(\"collectExportsAndImports - collectFromRequire\");\n  if (!isRequire(path)) return;\n\n  // This method can be reached many times from multiple visitors for the same path\n  // So we need to check if we already processed it\n  if (state.processedRequires.has(path)) return;\n  state.processedRequires.add(path);\n\n  const { parentPath: callExpression } = path;\n  if (!callExpression.isCallExpression()) {\n    // It's wrong `require`\n    return;\n  }\n\n  const [sourcePath] = callExpression.get('arguments');\n  if (!sourcePath || !sourcePath.isStringLiteral()) {\n    // Import should have at least one argument, and it should be StringLiteral\n    return;\n  }\n\n  const source = sourcePath.node.value;\n\n  const { parentPath: container, key } = callExpression;\n\n  if (container.isCallExpression()) {\n    // It may be transpiled import such as\n    // `var _atomic = _interopRequireDefault(require(\"@linaria/atomic\"));`\n    const imported = getImportExportTypeByInteropFunction(\n      container,\n      callExpression\n    );\n    if (!imported) {\n      // It's not a transpiled import.\n      // TODO: Can we guess that it's a namespace import?\n      debug('Unknown wrapper of require: %o', container.node.callee);\n      return;\n    }\n\n    if (imported === 're-export:*') {\n      state.reexports.push({\n        exported: '*',\n        imported: '*',\n        local: path,\n        source,\n      });\n\n      return;\n    }\n\n    let { parentPath: variableDeclarator } = container;\n    if (variableDeclarator.isCallExpression()) {\n      if (variableDeclarator.get('callee').isIdentifier({ name: '_extends' })) {\n        variableDeclarator = variableDeclarator.parentPath!;\n      }\n    }\n\n    if (!variableDeclarator.isVariableDeclarator()) {\n      // TODO: Where else it can be?\n      debug('Unexpected require inside %o', variableDeclarator.node.type);\n      return;\n    }\n\n    const id = variableDeclarator.get('id');\n    if (!id.isIdentifier()) {\n      debug('Id should be Identifier %o', variableDeclarator.node.type);\n      return;\n    }\n\n    if (imported === 'import:*') {\n      const unfolded = unfoldNamespaceImport({\n        imported: '*',\n        local: id,\n        source,\n        type: 'cjs',\n      });\n      state.imports.push(...unfolded);\n    } else {\n      state.imports.push({\n        imported,\n        local: id,\n        source,\n        type: 'cjs',\n      });\n    }\n  }\n\n  if (container.isMemberExpression()) {\n    // It is `require('@linaria/shaker').dep`\n    const property = container.get('property');\n    if (!property.isIdentifier() && !property.isStringLiteral()) {\n      debug(\n        'Property should be Identifier or StringLiteral %s',\n        property.node.type\n      );\n\n      return;\n    }\n\n    const { parentPath: variableDeclarator } = container;\n\n    if (variableDeclarator.isVariableDeclarator()) {\n      // It is `const … = require('@linaria/shaker').dep`;\n      const id = variableDeclarator.get('id');\n      if (id.isIdentifier()) {\n        state.imports.push({\n          imported: getValue(property),\n          local: id,\n          source,\n          type: 'cjs',\n        });\n      } else {\n        debug('Id should be Identifier %o', variableDeclarator.node.type);\n      }\n    } else {\n      // Maybe require is passed as an argument to some function?\n      // Just use the whole MemberExpression as a local\n      state.imports.push({\n        imported: getValue(property),\n        local: container,\n        source,\n        type: 'cjs',\n      });\n    }\n\n    return;\n  }\n\n  // Is it `const something = require(\"something\")`?\n  if (key === 'init' && container.isVariableDeclarator()) {\n    importFromVariableDeclarator(container, true).forEach((prop) => {\n      if (prop.what === '*') {\n        const unfolded = unfoldNamespaceImport({\n          imported: '*',\n          local: prop.as,\n          source,\n          type: 'cjs',\n        });\n\n        state.imports.push(...unfolded);\n      } else {\n        state.imports.push({\n          imported: prop.what,\n          local: prop.as,\n          source,\n          type: 'cjs',\n        });\n      }\n    });\n  }\n\n  if (container.isExpressionStatement()) {\n    // Looks like standalone require\n    state.imports.push({\n      imported: 'side-effect',\n      local: container,\n      source,\n    });\n  }\n}\n\nfunction collectFromVariableDeclarator(\n  path: NodePath<VariableDeclarator>,\n  state: ILocalState\n): void {\n  console.log(\"collectExportsAndImports - collectFromVariableDeclarator\");\n  let found = false;\n  path.traverse({\n    Identifier(identifierPath) {\n      if (isRequire(identifierPath)) {\n        collectFromRequire(identifierPath, state);\n        found = true;\n      }\n    },\n  });\n\n  if (found) {\n    path.skip();\n  }\n}\n\nfunction isChainOfVoidAssignment(\n  path: NodePath<AssignmentExpression>\n): boolean {\n  console.log(\"collectExportsAndImports - isChainOfVoidAssignment\");\n  const right = path.get('right');\n  if (right.isUnaryExpression({ operator: 'void' })) {\n    return true;\n  }\n\n  if (right.isAssignmentExpression()) {\n    return isChainOfVoidAssignment(right);\n  }\n\n  return false;\n}\n\nfunction getReturnValue(\n  path: NodePath<FunctionNode>\n): NodePath<Expression> | undefined {\n  console.log(\"collectExportsAndImports - getReturnValue\");\n  if (path.node.params.length !== 0) return undefined;\n\n  const body = path.get('body') as\n    | NodePath<BlockStatement>\n    | NodePath<Expression>;\n  if (body.isExpression()) {\n    return body;\n  }\n\n  if (body.node.body.length === 1) {\n    const returnStatement = body.get('body')?.[0];\n    if (!returnStatement.isReturnStatement()) return undefined;\n    const argument = returnStatement.get('argument');\n    if (!argument.isExpression()) return undefined;\n    return argument;\n  }\n\n  return undefined;\n}\n\nfunction getGetterValueFromDescriptor(\n  descriptor: NodePath<ObjectExpression>\n): NodePath<Expression> | undefined {\n  console.log(\"collectExportsAndImports - getGetterValueFromDescriptor\");\n  const props = descriptor\n    .get('properties')\n    .filter(isTypedNode('ObjectProperty'));\n\n  const getter = props.find((p) => p.get('key').isIdentifier({ name: 'get' }));\n  const value = getter?.get('value');\n\n  if (value?.isFunctionExpression() || value?.isArrowFunctionExpression()) {\n    return getReturnValue(value);\n  }\n\n  const valueProp = props.find((p) =>\n    p.get('key').isIdentifier({ name: 'value' })\n  );\n\n  const valueValue = valueProp?.get('value');\n\n  return valueValue?.isExpression() ? valueValue : undefined;\n}\n\nfunction addExport(path: NodePath, exported: string, state: ILocalState): void {\n  console.log(\"collectExportsAndImports - addExport\");\n  function getRelatedImport() {\n    console.log(\"collectExportsAndImports - getRelatedImport\");\n    if (path.isMemberExpression()) {\n      const object = path.get('object');\n      if (!object.isIdentifier()) {\n        return undefined;\n      }\n\n      const objectBinding = object.scope.getBinding(object.node.name);\n      if (!objectBinding) {\n        return undefined;\n      }\n\n      if (objectBinding.path.isVariableDeclarator()) {\n        collectFromVariableDeclarator(objectBinding.path, state);\n      }\n\n      const found = state.imports.find(\n        (i) =>\n          objectBinding.identifier === i.local.node ||\n          objectBinding.referencePaths.some((p) => i.local.isAncestor(p))\n      );\n\n      if (!found) {\n        return undefined;\n      }\n\n      const property = path.get('property');\n      let what = '*';\n      if (path.node.computed && property.isStringLiteral()) {\n        what = property.node.value;\n      } else if (!path.node.computed && property.isIdentifier()) {\n        what = property.node.name;\n      }\n\n      return {\n        import: { ...found, local: path },\n        what,\n      };\n    }\n\n    return undefined;\n  }\n\n  const relatedImport = getRelatedImport();\n  if (relatedImport) {\n    // eslint-disable-next-line no-param-reassign\n    state.reexports.push({\n      local: relatedImport.import.local,\n      imported: relatedImport.import.imported,\n      source: relatedImport.import.source,\n      exported,\n    });\n  } else {\n    // eslint-disable-next-line no-param-reassign\n    state.exports[exported] = path;\n  }\n}\n\nconst saveRef = (\n  state: ILocalState,\n  exportName: string,\n  memberExpression: NodePath<MemberExpression>\n) => {\n  console.log(\"collectExportsAndImports - saveRef\");\n  // Save all export.____ usages for later\n  if (!state.exportRefs.has(exportName)) {\n    state.exportRefs.set(exportName, []);\n  }\n\n  state.exportRefs.get(exportName)!.push(memberExpression);\n};\n\nfunction collectFromExports(\n  path: NodePath<Identifier>,\n  state: ILocalState\n): void {\n  console.log(\"collectExportsAndImports - collectFromExports\");\n  if (!isExports(path)) return;\n\n  if (path.parentPath.isMemberExpression({ object: path.node })) {\n    // It is `exports.prop = …`\n    const memberExpression = path.parentPath;\n    const property = memberExpression.get('property');\n    if (!property.isIdentifier() || memberExpression.node.computed) {\n      return;\n    }\n\n    const exportName = property.node.name;\n\n    const assignmentExpression = memberExpression.parentPath;\n\n    if (\n      !assignmentExpression.isAssignmentExpression({\n        left: memberExpression.node,\n      })\n    ) {\n      // If it's not `exports.prop = …`. Just save it.\n      saveRef(state, exportName, memberExpression);\n      return;\n    }\n\n    const right = assignmentExpression.get('right');\n\n    if (isChainOfVoidAssignment(assignmentExpression)) {\n      // It is `exports.foo = void 0`\n      return;\n    }\n\n    if (exportName === '__esModule') {\n      // eslint-disable-next-line no-param-reassign\n      state.isEsModule = true;\n      return;\n    }\n\n    saveRef(state, exportName, memberExpression);\n    // eslint-disable-next-line no-param-reassign\n    state.exports[property.node.name] = right;\n\n    return;\n  }\n\n  if (\n    path.parentPath.isCallExpression() &&\n    path.parentPath.get('callee').matchesPattern('Object.defineProperty')\n  ) {\n    const [obj, prop, descriptor] = path.parentPath.get('arguments');\n    if (\n      obj?.isIdentifier(path.node) &&\n      prop?.isStringLiteral() &&\n      descriptor?.isObjectExpression()\n    ) {\n      if (prop.node.value === '__esModule') {\n        // eslint-disable-next-line no-param-reassign\n        state.isEsModule = true;\n      } else {\n        /**\n         *  Object.defineProperty(exports, \"token\", {\n         *    enumerable: true,\n         *    get: function get() {\n         *      return _unknownPackage.token;\n         *    }\n         *  });\n         */\n        const exported = prop.node.value;\n        const local = getGetterValueFromDescriptor(descriptor);\n        if (local) {\n          addExport(local, exported, state);\n        }\n      }\n    } else if (\n      obj?.isIdentifier(path.node) &&\n      prop?.isIdentifier() &&\n      descriptor?.isObjectExpression()\n    ) {\n      /**\n       *  Object.defineProperty(exports, key, {\n       *    enumerable: true,\n       *    get: function get() {\n       *      return _unknownPackage[key];\n       *    }\n       *  });\n       */\n      const local = getGetterValueFromDescriptor(descriptor);\n      if (local) {\n        addExport(local, '*', state);\n      }\n    }\n  }\n}\n\nfunction collectFromRequireOrExports(\n  path: NodePath<Identifier>,\n  state: ILocalState\n): void {\n  console.log(\"collectExportsAndImports - collectFromRequireOrExports\");\n  if (isRequire(path)) {\n    collectFromRequire(path, state);\n  } else if (isExports(path)) {\n    collectFromExports(path, state);\n  }\n}\n\nfunction unfoldNamespaceImport(\n  importItem: IImport & { imported: '*' }\n): IImport[] {\n  console.log(\"collectExportsAndImports - unfoldNamespaceImport\");\n  const result: IImport[] = [];\n  const { local } = importItem;\n  if (!local.isIdentifier()) {\n    // TODO: handle it\n    return [importItem];\n  }\n\n  const binding = getScope(local).getBinding(local.node.name);\n  if (!binding?.referenced) {\n    // Imported namespace is not referenced and probably not used,\n    // but it can have side effects, so we should keep it as is\n    return [\n      {\n        ...importItem,\n        imported: 'side-effect',\n      },\n    ];\n  }\n\n  for (const referencePath of binding?.referencePaths ?? []) {\n    if (\n      referencePath.find(\n        (ancestor) => ancestor.isTSType() || ancestor.isFlowType()\n      )\n    ) {\n      continue;\n    }\n\n    const { parentPath } = referencePath;\n    if (parentPath?.isMemberExpression() && referencePath.key === 'object') {\n      const property = parentPath.get('property');\n      const object = parentPath.get('object');\n      let imported: string | null;\n      if (parentPath.node.computed && property.isStringLiteral()) {\n        imported = property.node.value;\n      } else if (!parentPath.node.computed && property.isIdentifier()) {\n        imported = property.node.name;\n      } else {\n        imported = null;\n      }\n\n      if (object.isIdentifier() && imported) {\n        result.push({\n          ...importItem,\n          imported,\n          local: parentPath,\n        });\n      } else {\n        result.push(importItem);\n        break;\n      }\n\n      continue;\n    }\n\n    if (parentPath?.isVariableDeclarator() && referencePath.key === 'init') {\n      importFromVariableDeclarator(parentPath, true).map((prop) =>\n        result.push({ ...importItem, imported: prop.what, local: prop.as })\n      );\n\n      continue;\n    }\n\n    if (\n      parentPath?.isCallExpression() &&\n      referencePath.listKey === 'arguments'\n    ) {\n      // The defined variable is used as a function argument. Let's try to figure out what is imported.\n      const importType = getImportExportTypeByInteropFunction(\n        parentPath,\n        referencePath\n      );\n\n      if (!importType) {\n        // Imported value is used as an unknown function argument,\n        // so we can't predict usage and import it as is.\n        result.push(importItem);\n        break;\n      }\n\n      if (importType === 'default') {\n        result.push({\n          ...importItem,\n          imported: 'default',\n          local: parentPath.get('id') as NodePath<Identifier>,\n        });\n\n        continue;\n      }\n\n      if (importType === 'import:*') {\n        result.push(importItem);\n        break;\n      }\n\n      debug('unfoldNamespaceImports: unknown import type %o', importType);\n\n      result.push(importItem);\n      continue;\n    }\n\n    if (\n      parentPath?.isExportSpecifier() ||\n      parentPath?.isExportDefaultDeclaration()\n    ) {\n      // The whole namespace is re-exported\n      result.push(importItem);\n      break;\n    }\n\n    // Otherwise, we can't predict usage and import it as is\n    // TODO: handle more cases\n    debug(\n      'unfoldNamespaceImports: unknown reference %o',\n      referencePath.node.type\n    );\n    result.push(importItem);\n    break;\n  }\n\n  return result;\n}\n\nfunction collectFromExportAllDeclaration(\n  path: NodePath<ExportAllDeclaration>,\n  state: ILocalState\n): void {\n  console.log(\"collectExportsAndImports - collectFromExportAllDeclaration\");\n  if (isType(path)) return;\n  const source = path.get('source')?.node?.value;\n  if (!source) return;\n\n  // It is `export * from './css';`\n  state.reexports.push({\n    exported: '*',\n    imported: '*',\n    local: path,\n    source,\n  });\n}\n\nfunction collectFromExportSpecifier(\n  path: NodePath<\n    ExportSpecifier | ExportDefaultSpecifier | ExportNamespaceSpecifier\n  >,\n  source: string | undefined,\n  state: ILocalState\n): void {\n  console.log(\"collectExportsAndImports - collectFromExportSpecifier\");\n  if (path.isExportSpecifier()) {\n    const exported = getValue(path.get('exported'));\n    if (source) {\n      // It is `export { foo } from './css';`\n      const imported = path.get('local').node.name;\n      state.reexports.push({\n        exported,\n        imported,\n        local: path,\n        source,\n      });\n    } else {\n      const local = path.get('local');\n      // eslint-disable-next-line no-param-reassign\n      state.exports[exported] = local;\n    }\n\n    return;\n  }\n\n  if (path.isExportDefaultSpecifier() && source) {\n    // It is `export default from './css';`\n    state.reexports.push({\n      exported: 'default',\n      imported: 'default',\n      local: path,\n      source,\n    });\n  }\n\n  if (path.isExportNamespaceSpecifier() && source) {\n    const exported = path.get('exported').node.name;\n    // It is `export * as foo from './css';`\n    state.reexports.push({\n      exported,\n      imported: '*',\n      local: path,\n      source,\n    });\n  }\n\n  // TODO: handle other cases\n  debug(\n    'collectFromExportSpecifier: unprocessed ExportSpecifier %o',\n    path.node.type\n  );\n}\n\nfunction collectFromExportNamedDeclaration(\n  path: NodePath<ExportNamedDeclaration>,\n  state: ILocalState\n): void {\n  console.log(\"collectExportsAndImports - collectFromExportNamedDeclaration\");\n  if (isType(path)) return;\n\n  const source = path.get('source')?.node?.value;\n  const specifiers = path.get('specifiers');\n  if (specifiers) {\n    specifiers.forEach((specifier) =>\n      collectFromExportSpecifier(specifier, source, state)\n    );\n  }\n\n  const declaration = path.get('declaration');\n  if (declaration.isVariableDeclaration()) {\n    declaration.get('declarations').forEach((declarator) => {\n      // eslint-disable-next-line no-param-reassign\n      state.exports = {\n        ...state.exports,\n        ...exportFromVariableDeclarator(declarator),\n      };\n    });\n  }\n\n  if (declaration.isTSEnumDeclaration()) {\n    // eslint-disable-next-line no-param-reassign\n    state.exports[declaration.get('id').node.name] = declaration;\n  }\n\n  if (declaration.isFunctionDeclaration()) {\n    const id = declaration.get('id');\n    if (id.isIdentifier()) {\n      // eslint-disable-next-line no-param-reassign\n      state.exports[id.node.name] = id;\n    }\n  }\n\n  if (declaration.isClassDeclaration()) {\n    const id = declaration.get('id');\n    if (id.isIdentifier()) {\n      // eslint-disable-next-line no-param-reassign\n      state.exports[id.node.name] = id;\n    }\n  }\n}\n\nfunction collectFromExportDefaultDeclaration(\n  path: NodePath<ExportDefaultDeclaration>,\n  state: ILocalState\n): void {\n  console.log(\"collectExportsAndImports - collectFromExportDefaultDeclaration\");\n  if (isType(path)) return;\n\n  // eslint-disable-next-line no-param-reassign\n  state.exports.default = path.get('declaration');\n}\n\nfunction collectFromAssignmentExpression(\n  path: NodePath<AssignmentExpression>,\n  state: ILocalState\n): void {\n  console.log(\"collectExportsAndImports - collectFromAssignmentExpression\");\n  if (isChainOfVoidAssignment(path)) {\n    return;\n  }\n\n  const left = path.get('left');\n  const right = path.get('right');\n\n  let exported: IReexport['exported'] | undefined;\n\n  const isExportRef =\n    left.isMemberExpression() && isExports(left.get('object'));\n  if (isExportRef) {\n    const property = left.get('property');\n    if (!left.node.computed && property.isIdentifier()) {\n      exported = property.node.name;\n    } else if (left.node.computed && property.isStringLiteral()) {\n      exported = property.node.value;\n    }\n  } else if (isExports(left)) {\n    // module.exports = ...\n    if (!isAlreadyProcessed(right)) {\n      exported = 'default';\n    }\n  }\n\n  if (!exported) return;\n\n  if (exported === '__esModule') {\n    // eslint-disable-next-line no-param-reassign\n    state.isEsModule = true;\n    return;\n  }\n\n  if (!isRequireCall(right)) {\n    const relatedImport = state.imports.find((imp) => imp.local === right);\n    if (relatedImport) {\n      state.reexports.push({\n        exported,\n        ...relatedImport,\n      });\n    } else {\n      // eslint-disable-next-line no-param-reassign\n      state.exports[exported] = right;\n    }\n\n    if (isExportRef) {\n      saveRef(state, exported, left);\n    }\n\n    path.skip();\n    return;\n  }\n\n  const sourcePath = right.get('arguments')?.[0];\n  const source = sourcePath.isStringLiteral()\n    ? sourcePath.node.value\n    : undefined;\n  if (!source) return;\n\n  // It is `exports.foo = require('./css');`\n\n  if (state.exports[exported]) {\n    // eslint-disable-next-line no-param-reassign\n    delete state.exports[exported];\n  }\n\n  state.reexports.push({\n    exported,\n    imported: '*',\n    local: path,\n    source,\n  });\n\n  path.skip();\n}\n\nfunction collectAllFromCall(\n  path: NodePath<CallExpression>,\n  require: number | NodePath,\n  state: ILocalState\n) {\n  console.log(\"collectExportsAndImports - collectAllFromCall\");\n  const requireCall =\n    typeof require === 'number' ? path.get('arguments')[require] : require;\n  if (!requireCall.isCallExpression()) return;\n  const callee = requireCall.get('callee');\n  const sourcePath = requireCall.get('arguments')?.[0];\n  if (!isRequire(callee) || !sourcePath.isStringLiteral()) return;\n\n  const source = sourcePath.node.value;\n  if (!source) return;\n\n  state.reexports.push({\n    exported: '*',\n    imported: '*',\n    local: path,\n    source,\n  });\n\n  path.skip();\n}\n\nfunction collectFromMap(map: NodePath<ObjectExpression>, state: ILocalState) {\n  console.log(\"collectExportsAndImports - collectFromMap\");\n  const properties = map.get('properties');\n  properties.forEach((property) => {\n    if (!property.isObjectProperty()) return;\n    const key = property.get('key');\n    const value = property.get('value');\n    if (!key.isIdentifier()) return;\n    const exported = key.node.name;\n\n    if (!value.isFunction()) return;\n    if (value.node.params.length !== 0) return;\n\n    const returnValue = getReturnValue(value);\n    if (!returnValue) return;\n\n    addExport(returnValue, exported, state);\n  });\n}\n\nfunction collectMapFromCall(\n  path: NodePath<CallExpression>,\n  mapPosition: number,\n  state: ILocalState\n) {\n  console.log(\"collectExportsAndImports - collectMapFromCall\");\n  const map = path.get('arguments')[mapPosition];\n  if (!map.isObjectExpression()) return;\n\n  collectFromMap(map, state);\n\n  path.skip();\n}\n\nfunction collectFromEsbuildReExportCall(\n  path: NodePath<CallExpression>,\n  state: ILocalState\n) {\n  console.log(\"collectExportsAndImports - collectFromEsbuildReExportCall\");\n  const [sourceExports, someCall, exports] = path.get('arguments');\n  if (\n    !sourceExports.isIdentifier({ name: 'source_exports' }) &&\n    !isExports(sourceExports)\n  )\n    return;\n  if (!someCall.isCallExpression()) return;\n\n  let requireCall = someCall;\n  while (!isRequire(requireCall.get('callee'))) {\n    const args = requireCall.get('arguments');\n    if (args.length !== 1) {\n      return;\n    }\n\n    const firstArg = args[0];\n    if (!firstArg.isCallExpression()) {\n      return;\n    }\n\n    requireCall = firstArg;\n  }\n\n  if (exports !== undefined && !isExports(exports)) return;\n\n  const sourcePath = requireCall.get('arguments')?.[0];\n  if (!sourcePath.isStringLiteral()) return;\n\n  state.reexports.push({\n    exported: '*',\n    imported: '*',\n    local: path,\n    source: sourcePath.node.value,\n  });\n\n  path.skip();\n}\n\nfunction collectFromCallExpression(\n  path: NodePath<CallExpression>,\n  state: ILocalState\n) {\n  console.log(\"collectExportsAndImports - collectFromCallExpression\");\n  const maybeExportStart = path.get('callee');\n  if (!maybeExportStart.isIdentifier()) {\n    return;\n  }\n\n  if (\n    matchCall(path, [\n      ['__exportStar', isExports, isCallExpression('__toModule')],\n    ])\n  ) {\n    // __exportStar(exports, __toModule(require('…')));\n\n    const secondArg = path.get('arguments')[1] as NodePath<CallExpression>;\n    collectAllFromCall(path, secondArg.get('arguments')[0], state);\n    return;\n  }\n\n  // TypeScript & swc\n  if (\n    matchCall(path, [\n      ['__exportStart', isRequireCall, isExports],\n      ['_exportStar', isRequireCall, isExports],\n      ['_export_star', isRequireCall, isExports],\n      ['__export', isRequireCall], // TypeScript <=3.8.3\n    ])\n  ) {\n    collectAllFromCall(path, 0, state);\n    return;\n  }\n\n  if (matchCall(path, [['_export', isExports, isObjectExpression]])) {\n    collectMapFromCall(path, 1, state);\n    return;\n  }\n\n  if (\n    matchCall(path, [\n      ['_extends', isEmptyObject, isRequireCall], // swc <=1.3.16\n    ])\n  ) {\n    collectAllFromCall(path, 1, state);\n    return;\n  }\n\n  // esbuild\n  if (\n    matchCall(path, [\n      ['__export', isExports, isObjectExpression],\n      ['__export', isIdentifier('source_exports'), isObjectExpression],\n    ])\n  ) {\n    collectMapFromCall(path, 1, state);\n    return;\n  }\n\n  if (\n    matchCall(path, [\n      // Different variants of re-exports in esbuild\n      [\n        '__reExport',\n        isIdentifier('source_exports'),\n        isCallExpression,\n        isExports,\n      ],\n      ['__reExport', isIdentifier('source_exports'), isCallExpression],\n      ['__reExport', isExports, isCallExpression],\n    ])\n  ) {\n    collectFromEsbuildReExportCall(path, state);\n  }\n}\n\nexport function collectExportsAndImports(\n  path: NodePath<Program>,\n  cacheMode: 'disabled' | 'force' | 'enabled' = 'enabled'\n): IState {\n  console.log(\"collectExportsAndImports - collectExportsAndImports\");\n  const localState: ILocalState = {\n    deadExports: [],\n    exportRefs: new Map(),\n    exports: {},\n    imports: [],\n    reexports: [],\n    isEsModule: path.node.sourceType === 'module',\n    processedRequires: new WeakSet(),\n  };\n\n  const cache =\n    cacheMode !== 'disabled'\n      ? getTraversalCache<IState>(path, 'collectExportsAndImports')\n      : undefined;\n\n  if (cacheMode === 'enabled' && cache?.has(path)) {\n    return cache.get(path) ?? localState;\n  }\n\n  path.traverse(\n    {\n      AssignmentExpression: collectFromAssignmentExpression,\n      CallExpression: collectFromCallExpression,\n      ExportAllDeclaration: collectFromExportAllDeclaration,\n      ExportDefaultDeclaration: collectFromExportDefaultDeclaration,\n      ExportNamedDeclaration: collectFromExportNamedDeclaration,\n      ImportDeclaration: collectFromImportDeclaration,\n      Import: collectFromDynamicImport,\n      Identifier: collectFromRequireOrExports,\n      VariableDeclarator: collectFromVariableDeclarator,\n    },\n    localState\n  );\n\n  const { processedRequires, ...state } = localState;\n\n  cache?.set(path, state);\n\n  return state;\n}\n"],"mappings":";;;;;;;AA+BA,IAAAA,OAAA,GAAAC,OAAA;AAEA,IAAAC,SAAA,GAAAD,OAAA;AACA,IAAAE,UAAA,GAAAF,OAAA;AACA,IAAAG,UAAA,GAAAH,OAAA;AACA,IAAAI,UAAA,GAAAJ,OAAA;AACA,IAAAK,YAAA,GAAAL,OAAA;AACA,IAAAM,eAAA,GAAAN,OAAA;AAtCA;AACA;;AAoDkE;;AAsB3D,MAAMO,gBAAgB,GAC3BC,IAAiC,IACHA,IAAI,CAACC,QAAQ,KAAK,aAAa;AAACC,OAAA,CAAAH,gBAAA,GAAAA,gBAAA;AAEzD,MAAMI,cAAc,GACzBH,IAAiC,IACbA,IAAI,CAACC,QAAQ,KAAK,aAAa;AAACC,OAAA,CAAAC,cAAA,GAAAA,cAAA;AAEtD,SAASC,QAAQA,CAAC;EAAEC;AAA2C,CAAC,EAAU;EACxEC,OAAO,CAACC,GAAG,CAAC,qCAAqC,CAAC;EAClD,OAAOF,IAAI,CAACG,IAAI,KAAK,YAAY,GAAGH,IAAI,CAACI,IAAI,GAAGJ,IAAI,CAACK,KAAK;AAC5D;;AAEA;AACA,MAAMC,MAAM,GAAIC,CAEf,IACE,YAAY,IAAIA,CAAC,CAACP,IAAI,IAAIO,CAAC,CAACP,IAAI,CAACQ,UAAU,KAAK,MAAM,IACtD,YAAY,IAAID,CAAC,CAACP,IAAI,IAAIO,CAAC,CAACP,IAAI,CAACS,UAAU,KAAK,MAAO;;AAE1D;;AAEA,MAAMC,UAKL,GAAG;EACFC,eAAeA,CAACC,IAA+B,EAAEC,MAAM,EAAa;IAClE,IAAIP,MAAM,CAACM,IAAI,CAAC,EAAE,OAAO,EAAE;IAC3B,MAAMhB,QAAQ,GAAGG,QAAQ,CAACa,IAAI,CAACE,GAAG,CAAC,UAAU,CAAC,CAAC;IAC/C,MAAMC,KAAK,GAAGH,IAAI,CAACE,GAAG,CAAC,OAAO,CAAC;IAC/B,OAAO,CAAC;MAAElB,QAAQ;MAAEmB,KAAK;MAAEF,MAAM;MAAEV,IAAI,EAAE;IAAM,CAAC,CAAC;EACnD,CAAC;EAEDa,sBAAsBA,CACpBJ,IAAsC,EACtCC,MAAM,EACK;IACX,MAAME,KAAK,GAAGH,IAAI,CAACE,GAAG,CAAC,OAAO,CAAC;IAC/B,OAAO,CAAC;MAAElB,QAAQ,EAAE,SAAS;MAAEmB,KAAK;MAAEF,MAAM;MAAEV,IAAI,EAAE;IAAM,CAAC,CAAC;EAC9D,CAAC;EAEDc,wBAAwBA,CACtBL,IAAwC,EACxCC,MAAM,EACK;IACX,MAAME,KAAK,GAAGH,IAAI,CAACE,GAAG,CAAC,OAAO,CAAC;IAC/B,OAAOI,qBAAqB,CAAC;MAAEtB,QAAQ,EAAE,GAAG;MAAEmB,KAAK;MAAEF,MAAM;MAAEV,IAAI,EAAE;IAAM,CAAC,CAAC;EAC7E;AACF,CAAC;AAED,SAASgB,4BAA4BA,CACnCP,IAAiC,EACjCQ,KAAkB,EACZ;EACNnB,OAAO,CAACC,GAAG,CAAC,yDAAyD,CAAC;EACtE;EACA,IAAII,MAAM,CAACM,IAAI,CAAC,EAAE;EAElB,MAAMC,MAAM,GAAGd,QAAQ,CAACa,IAAI,CAACE,GAAG,CAAC,QAAQ,CAAC,CAAC;EAC3C,MAAMO,UAAU,GAAGT,IAAI,CAACE,GAAG,CAAC,YAAY,CAAC;EAEzC,IAAIO,UAAU,CAACC,MAAM,KAAK,CAAC,EAAE;IAC3BF,KAAK,CAACG,OAAO,CAACC,IAAI,CAAC;MAAE5B,QAAQ,EAAE,aAAa;MAAEmB,KAAK,EAAEH,IAAI;MAAEC;IAAO,CAAC,CAAC;EACtE;EAEAQ,UAAU,CAACI,OAAO,CAA4BC,SAAsB,IAAK;IACvE,IAAIA,SAAS,CAACC,iBAAiB,CAAC,CAAC,IAAIrB,MAAM,CAACoB,SAAS,CAAC,EAAE;IAExD,MAAME,SAAS,GAAGlB,UAAU,CAC1BgB,SAAS,CAAC1B,IAAI,CAACG,IAAI,CACc;IAEnCiB,KAAK,CAACG,OAAO,CAACC,IAAI,CAAC,GAAGI,SAAS,CAACF,SAAS,EAAEb,MAAM,CAAC,CAAC;EACrD,CAAC,CAAC;AACJ;AAOA,SAASgB,iBAAiBA,CAACjB,IAAc,EAAEkB,IAA8B,EAAE;EACzE7B,OAAO,CAACC,GAAG,CAAC,8CAA8C,CAAC;EAC3D,MAAM6B,MAAkB,GAAG,EAAE;EAC7B,IAAIC,OAAwB,GAAGpB,IAAI;EACnC,OAAOoB,OAAO,IAAIF,IAAI,CAACE,OAAO,CAAC,EAAE;IAC/BD,MAAM,CAACP,IAAI,CAACQ,OAAO,CAAC;IACpBA,OAAO,GAAGA,OAAO,CAACC,UAAU;EAC9B;EAEA,OAAOF,MAAM;AACf;AAEA,SAASG,gBAAgBA,CACvBC,aAAsC,EACvB;EACflC,OAAO,CAACC,GAAG,CAAC,6CAA6C,CAAC;EAC1D,MAAMkC,eAA8B,GAAG,EAAE;EACzCD,aAAa,CAACE,QAAQ,CAAC;IACrBC,UAAUA,CAACC,UAAU,EAAE;MACrB,IAAIA,UAAU,CAACC,mBAAmB,CAAC,CAAC,EAAE;QACpC,MAAMC,MAAM,GAAGF,UAAU,CAACN,UAAU;QACpC,IAAIQ,MAAM,CAACC,gBAAgB,CAAC;UAAErC,KAAK,EAAEkC,UAAU,CAACvC;QAAK,CAAC,CAAC,EAAE;UACvD,MAAM2C,KAAK,GAAGd,iBAAiB,CAACY,MAAM,EAAGlC,CAAC,IAAKA,CAAC,KAAK4B,aAAa,CAAC,CAChES,MAAM,CAAC,IAAAC,wBAAW,EAAC,gBAAgB,CAAC,CAAC,CACrCC,GAAG,CAAEvC,CAAC,IAAK;YACV,MAAMwC,GAAG,GAAGxC,CAAC,CAACO,GAAG,CAAC,KAAK,CAAC;YACxB,IAAI,CAACiC,GAAG,CAACC,YAAY,CAAC,CAAC,EAAE;cACvB;cACA,OAAO,IAAI;YACb;YAEA,OAAOD,GAAG;UACZ,CAAC,CAAC,CACDH,MAAM,CAACK,oBAAS,CAAC;UACpBN,KAAK,CAACO,OAAO,CAAC,CAAC;UAEf,IAAIP,KAAK,CAACrB,MAAM,GAAG,CAAC,EAAE;YACpBc,eAAe,CAACZ,IAAI,CAAC;cACnB2B,IAAI,EAAER,KAAK,CAAC,CAAC,CAAC,CAAC3C,IAAI,CAACI,IAAI;cACxBgD,EAAE,EAAEb;YACN,CAAC,CAAC;UACJ;UAEA;QACF;QAEA,IAAIE,MAAM,CAACY,aAAa,CAAC;UAAEC,QAAQ,EAAEf,UAAU,CAACvC;QAAK,CAAC,CAAC,EAAE;UACvDoC,eAAe,CAACZ,IAAI,CAAC;YACnB2B,IAAI,EAAE,GAAG;YACTC,EAAE,EAAEb;UACN,CAAC,CAAC;QACJ;MACF;IACF;EACF,CAAC,CAAC;EAEF,OAAOH,eAAe;AACxB;AAEA,MAAMmB,KAAK,GAAGC,cAAM,CAACC,MAAM,CAAC,oCAAoC,CAAC;AAEjE,SAASC,4BAA4BA,CACnC9C,IAAkC,EAClC+C,MAAe,EACA;EACf1D,OAAO,CAACC,GAAG,CAAC,yDAAyD,CAAC;EACtE,MAAM0D,EAAE,GAAGhD,IAAI,CAACE,GAAG,CAAC,IAAI,CAAC;EACzB,IAAI8C,EAAE,CAACZ,YAAY,CAAC,CAAC,EAAE;IACrB;IACA,OAAO,CACL;MACEI,EAAE,EAAEQ,EAAE;MACNT,IAAI,EAAE;IACR,CAAC,CACF;EACH;EAEA,IAAI,CAACQ,MAAM,EAAE;IACX;IACA;IACAJ,KAAK,CAAC,4BAA4B,CAAC;IACnC,OAAO,EAAE;EACX;EAEA,IAAIK,EAAE,CAACC,eAAe,CAAC,CAAC,EAAE;IACxB,OAAO3B,gBAAgB,CAAC0B,EAAE,CAAC;EAC7B;;EAEA;EACAL,KAAK,CAAC,qDAAqD,EAAEK,EAAE,CAAC5D,IAAI,CAACG,IAAI,CAAC;EAE1E,OAAO,EAAE;AACX;AAEA,MAAM2D,QAAQ,GAAIlD,IAAc,IAAsC;EACpEX,OAAO,CAACC,GAAG,CAAC,qCAAqC,CAAC;EAClD,IAAIU,IAAI,CAACmD,gBAAgB,CAAC,CAAC,IAAInD,IAAI,CAACE,GAAG,CAAC,QAAQ,CAAC,CAACkD,oBAAoB,CAAC,CAAC,EAAE;IACxE,OAAOpD,IAAI;EACb;EAEA,IAAI,CAACA,IAAI,CAACqB,UAAU,EAAE;IACpB,OAAO,IAAI;EACb;EAEA,OAAO6B,QAAQ,CAAClD,IAAI,CAACqB,UAAU,CAAC;AAClC,CAAC;AAED,SAASgC,4BAA4BA,CACnCrD,IAAkC,EACzB;EACTX,OAAO,CAACC,GAAG,CAAC,yDAAyD,CAAC;EACtE,MAAM0D,EAAE,GAAGhD,IAAI,CAACE,GAAG,CAAC,IAAI,CAAC;EACzB,MAAMoD,IAAI,GAAGtD,IAAI,CAACE,GAAG,CAAC,MAAM,CAAC;;EAE7B;EACA,IAAI,CAACoD,IAAI,CAAClE,IAAI,IAAI4D,EAAE,CAACZ,YAAY,CAAC,CAAC,EAAE;IACnC,MAAMmB,OAAO,GAAG,IAAAC,kBAAQ,EAACxD,IAAI,CAAC,CAACyD,UAAU,CAACT,EAAE,CAAC5D,IAAI,CAACI,IAAI,CAAC;IACvD,IAAI,CAAC+D,OAAO,EAAE;MACZ,OAAO,CAAC,CAAC;IACX;IAEA,MAAMG,IAAI,GAAG,CACX,GAAGH,OAAO,CAACI,cAAc,EACzB,GAAGJ,OAAO,CAACK,kBAAkB,EAC7BL,OAAO,CAACvD,IAAI,CACb,CACEkC,GAAG,CAACgB,QAAQ,CAAC,CACbW,IAAI,CAACxB,oBAAS,CAAC;IAElB,IAAI,CAACqB,IAAI,EAAE;MACT,OAAO,CAAC,CAAC;IACX;IAEA,OAAO;MACL,CAACV,EAAE,CAAC5D,IAAI,CAACI,IAAI,GAAGkE;IAClB,CAAC;EACH;EAEA,IAAI,CAACJ,IAAI,IAAI,CAACA,IAAI,CAACQ,YAAY,CAAC,CAAC,EAAE;IACjC,OAAO,CAAC,CAAC;EACX;EAEA,IAAId,EAAE,CAACZ,YAAY,CAAC,CAAC,EAAE;IACrB;IACA,OAAO;MACL,CAACY,EAAE,CAAC5D,IAAI,CAACI,IAAI,GAAG8D;IAClB,CAAC;EACH;EAEA,IAAIN,EAAE,CAACC,eAAe,CAAC,CAAC,EAAE;IACxB;IACA,OAAO3B,gBAAgB,CAAC0B,EAAE,CAAC,CAACe,MAAM,CAChC,CAACC,GAAG,EAAEC,UAAU,MAAM;MACpB,GAAGD,GAAG;MACN,CAACC,UAAU,CAACzB,EAAE,CAACpD,IAAI,CAACI,IAAI,GAAG8D;IAC7B,CAAC,CAAC,EACF,CAAC,CACH,CAAC;EACH;;EAEA;EACAX,KAAK,CAAC,qDAAqD,EAAEK,EAAE,CAAC5D,IAAI,CAACG,IAAI,CAAC;EAE1E,OAAO,CAAC,CAAC;AACX;AAEA,SAAS2E,wBAAwBA,CAC/BlE,IAAsB,EACtBQ,KAAkB,EACZ;EACNnB,OAAO,CAACC,GAAG,CAAC,qDAAqD,CAAC;EAClE,MAAM;IAAE+B,UAAU,EAAE8C;EAAe,CAAC,GAAGnE,IAAI;EAC3C,IAAI,CAACmE,cAAc,CAAChB,gBAAgB,CAAC,CAAC,EAAE;IACtC;IACA;EACF;EAEA,MAAM,CAACiB,UAAU,CAAC,GAAGD,cAAc,CAACjE,GAAG,CAAC,WAAW,CAAC;EACpD,IAAI,CAACkE,UAAU,IAAI,CAACA,UAAU,CAACC,eAAe,CAAC,CAAC,EAAE;IAChD;IACA;EACF;EAEA,MAAMpE,MAAM,GAAGmE,UAAU,CAAChF,IAAI,CAACK,KAAK;EAEpC,IAAI;IAAE4B,UAAU,EAAEiD,SAAS;IAAEnC;EAAI,CAAC,GAAGgC,cAAc;EACnD,IAAII,SAAS,GAAG,KAAK;EAErB,IAAID,SAAS,CAACE,iBAAiB,CAAC,CAAC,EAAE;IACjC;IACAD,SAAS,GAAG,IAAI;IAChBpC,GAAG,GAAGmC,SAAS,CAACnC,GAAG;IACnBmC,SAAS,GAAGA,SAAS,CAACjD,UAAW;EACnC;;EAEA;EACA,IAAIc,GAAG,KAAK,MAAM,IAAImC,SAAS,CAACG,oBAAoB,CAAC,CAAC,EAAE;IACtD3B,4BAA4B,CAACwB,SAAS,EAAEC,SAAS,CAAC,CAACrC,GAAG,CAAEwC,IAAI,IAC1DlE,KAAK,CAACG,OAAO,CAACC,IAAI,CAAC;MACjB5B,QAAQ,EAAE0F,IAAI,CAACnC,IAAI;MACnBpC,KAAK,EAAEuE,IAAI,CAAClC,EAAE;MACdvC,MAAM;MACNV,IAAI,EAAE;IACR,CAAC,CACH,CAAC;EACH;AACF;AAEA,SAASoF,aAAaA,CAAC3E,IAA8B,EAAsB;EACzEX,OAAO,CAACC,GAAG,CAAC,0CAA0C,CAAC;EACvD,MAAMsF,MAAM,GAAG5E,IAAI,CAACE,GAAG,CAAC,QAAQ,CAAC;EACjC,IAAI0E,MAAM,CAACxC,YAAY,CAAC,CAAC,EAAE;IACzB,OAAOwC,MAAM,CAACxF,IAAI,CAACI,IAAI;EACzB;EAEA,IAAIoF,MAAM,CAACC,kBAAkB,CAAC,CAAC,EAAE;IAC/B,MAAMC,QAAQ,GAAGF,MAAM,CAAC1E,GAAG,CAAC,UAAU,CAAC;IACvC,IAAI4E,QAAQ,CAAC1C,YAAY,CAAC,CAAC,EAAE;MAC3B,OAAO0C,QAAQ,CAAC1F,IAAI,CAACI,IAAI;IAC3B;EACF;EAEA,OAAOuF,SAAS;AAClB;AAOA,MAAMC,SAAS,GAAGA,CAACrF,CAA2B,EAAEsF,KAAkB,KAAK;EACrE5F,OAAO,CAACC,GAAG,CAAC,sCAAsC,CAAC;EACnD,MAAME,IAAI,GAAGmF,aAAa,CAAChF,CAAC,CAAC;EAE7B,IAAIH,IAAI,KAAKuF,SAAS,EAAE;IACtB,OAAO,KAAK;EACd;EAEA,OAAOE,KAAK,CAACC,IAAI,CAAC,CAAC,CAACC,CAAC,EAAE,GAAGC,IAAI,CAAC,KAAK;IAClC,IAAI5F,IAAI,KAAK2F,CAAC,EAAE,OAAO,KAAK;IAC5B,MAAME,MAAM,GAAG1F,CAAC,CAACO,GAAG,CAAC,WAAW,CAAC;IACjC,IAAImF,MAAM,CAAC3E,MAAM,KAAK0E,IAAI,CAAC1E,MAAM,EAAE,OAAO,KAAK;IAC/C,OAAO0E,IAAI,CAACE,KAAK,CAAC,CAACC,GAAG,EAAEC,CAAC,KAAK;MAC5B,IAAID,GAAG,KAAK,GAAG,EAAE,OAAO,IAAI;MAC5B,IAAI,OAAOA,GAAG,KAAK,UAAU,EAAE,OAAOA,GAAG,CAACF,MAAM,CAACG,CAAC,CAAC,CAAC;MACpD,OAAOD,GAAG,KAAKF,MAAM,CAACG,CAAC,CAAC;IAC1B,CAAC,CAAC;EACJ,CAAC,CAAC;AACJ,CAAC;AAED,SAASC,oCAAoCA,CAC3CzF,IAA8B,EAC9B0F,OAAiB,EACmC;EACpDrG,OAAO,CAACC,GAAG,CAAC,iEAAiE,CAAC;EAC9E,IAAI0F,SAAS,CAAChF,IAAI,EAAE,CAAC,CAAC,cAAc,EAAE0F,OAAO,EAAG/F,CAAC,IAAK,IAAAgG,oBAAS,EAAChG,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE;IACrE,OAAO,aAAa;EACtB;EAEA,IACEqF,SAAS,CAAChF,IAAI,EAAE,CACd,CAAC,wBAAwB,EAAE0F,OAAO,CAAC;EAAE;EACrC,CAAC,0BAA0B,EAAEA,OAAO,CAAC;EAAE;EACvC,CAAC,iBAAiB,EAAEA,OAAO,CAAC,CAAE;EAAA,CAC/B,CAAC,EACF;IACA,OAAO,SAAS;EAClB;EAEA,IACEV,SAAS,CAAChF,IAAI,EAAE,CACd,CAAC,yBAAyB,EAAE0F,OAAO,CAAC;EAAE;EACtC,CAAC,2BAA2B,EAAEA,OAAO,CAAC;EAAE;EACxC,CAAC,cAAc,EAAEA,OAAO,CAAC;EAAE;EAC3B,CAAC,SAAS,EAAEA,OAAO,CAAC;EAAE;EACtB,CAAC,YAAY,EAAEA,OAAO,CAAC,CAAE;EAAA,CAC1B,CAAC,EACF;IACA,OAAO,UAAU;EACnB;EAEA,IACEV,SAAS,CAAChF,IAAI,EAAE,CACd,CAAC,UAAU,EAAE4F,aAAa,EAAEF,OAAO,CAAC;EAAE;EACtC,CAAC,QAAQ,EAAEA,OAAO,EAAEG,iBAAiB,CAAC;EAAE;EACxC,CAAC,WAAW,EAAEH,OAAO,EAAEG,iBAAiB,CAAC;EAAE;EAC3C,CAAC,0BAA0B,EAAEH,OAAO,EAAEG,iBAAiB,CAAC;EAAE;EAC1D,CAAC,4BAA4B,EAAEH,OAAO,EAAEG,iBAAiB,CAAC;EAAE;EAC5D,CAAC,2BAA2B,EAAEH,OAAO,CAAC;EAAE;EACxC,CAAC,6BAA6B,EAAEA,OAAO,CAAC,CAAE;EAAA,CAC3C,CAAC,EACF;IACA,OAAO,UAAU;EACnB;EAEA,OAAOX,SAAS;AAClB;AAEA,SAASe,kBAAkBA,CAAC9F,IAAc,EAAW;EACnDX,OAAO,CAACC,GAAG,CAAC,+CAA+C,CAAC;EAC5D,IACEU,IAAI,CAACmD,gBAAgB,CAAC,CAAC,IACvBnD,IAAI,CAACE,GAAG,CAAC,QAAQ,CAAC,CAACkC,YAAY,CAAC;IAAE5C,IAAI,EAAE;EAAe,CAAC,CAAC,EACzD;IACA;IACA,OAAO,IAAI;EACb;EAEA,OAAO,KAAK;AACd;AAEA,SAASuG,aAAaA,CAAC/F,IAAc,EAAoC;EACvEX,OAAO,CAACC,GAAG,CAAC,0CAA0C,CAAC;EACvD,OAAOU,IAAI,CAACmD,gBAAgB,CAAC,CAAC,IAAI,IAAA6C,oBAAS,EAAChG,IAAI,CAACE,GAAG,CAAC,QAAQ,CAAC,CAAC;AACjE;AAEA,SAAS0F,aAAaA,CAAC5F,IAAc,EAAsC;EACzEX,OAAO,CAACC,GAAG,CAAC,0CAA0C,CAAC;EACvD,OAAOU,IAAI,CAACiG,kBAAkB,CAAC,CAAC,IAAIjG,IAAI,CAACZ,IAAI,CAAC8G,UAAU,CAACxF,MAAM,KAAK,CAAC;AACvE;AAEA,SAASmF,iBAAiBA,CAAC7F,IAAc,EAAqC;EAC5EX,OAAO,CAACC,GAAG,CAAC,8CAA8C,CAAC;EAC3D,OAAOU,IAAI,CAAC6F,iBAAiB,CAAC,CAAC;AACjC;AAMA,SAAS1C,gBAAgBA,CAACgD,UAA6B,EAAE;EACvD9G,OAAO,CAACC,GAAG,CAAC,6CAA6C,CAAC;EAC1D,IAAI,OAAO6G,UAAU,KAAK,QAAQ,EAAE;IAClC,OAAQxG,CAAW,IACjBA,CAAC,CAACwD,gBAAgB,CAAC,CAAC,IACpBxD,CAAC,CAACO,GAAG,CAAC,QAAQ,CAAC,CAACkC,YAAY,CAAC;MAAE5C,IAAI,EAAE2G;IAAW,CAAC,CAAC;EACtD;EAEA,OAAOA,UAAU,CAAChD,gBAAgB,CAAC,CAAC;AACtC;AAEA,SAAS8C,kBAAkBA,CACzBjG,IAAc,EACsB;EACpCX,OAAO,CAACC,GAAG,CAAC,+CAA+C,CAAC;EAC5D,OAAOU,IAAI,CAACiG,kBAAkB,CAAC,CAAC;AAClC;AAEA,SAAS7D,YAAYA,CAAC5C,IAAY,EAAE;EAClCH,OAAO,CAACC,GAAG,CAAC,yCAAyC,CAAC;EACtD,OAAQU,IAAc,IACpBA,IAAI,CAACoC,YAAY,CAAC;IAAE5C;EAAK,CAAC,CAAC;AAC/B;AAEA,SAAS4G,kBAAkBA,CACzBpG,IAA0B,EAC1BQ,KAAkB,EACZ;EACNnB,OAAO,CAACC,GAAG,CAAC,+CAA+C,CAAC;EAC5D,IAAI,CAAC,IAAA0G,oBAAS,EAAChG,IAAI,CAAC,EAAE;;EAEtB;EACA;EACA,IAAIQ,KAAK,CAAC6F,iBAAiB,CAACC,GAAG,CAACtG,IAAI,CAAC,EAAE;EACvCQ,KAAK,CAAC6F,iBAAiB,CAACE,GAAG,CAACvG,IAAI,CAAC;EAEjC,MAAM;IAAEqB,UAAU,EAAE8C;EAAe,CAAC,GAAGnE,IAAI;EAC3C,IAAI,CAACmE,cAAc,CAAChB,gBAAgB,CAAC,CAAC,EAAE;IACtC;IACA;EACF;EAEA,MAAM,CAACiB,UAAU,CAAC,GAAGD,cAAc,CAACjE,GAAG,CAAC,WAAW,CAAC;EACpD,IAAI,CAACkE,UAAU,IAAI,CAACA,UAAU,CAACC,eAAe,CAAC,CAAC,EAAE;IAChD;IACA;EACF;EAEA,MAAMpE,MAAM,GAAGmE,UAAU,CAAChF,IAAI,CAACK,KAAK;EAEpC,MAAM;IAAE4B,UAAU,EAAEiD,SAAS;IAAEnC;EAAI,CAAC,GAAGgC,cAAc;EAErD,IAAIG,SAAS,CAACnB,gBAAgB,CAAC,CAAC,EAAE;IAChC;IACA;IACA,MAAMnE,QAAQ,GAAGyG,oCAAoC,CACnDnB,SAAS,EACTH,cACF,CAAC;IACD,IAAI,CAACnF,QAAQ,EAAE;MACb;MACA;MACA2D,KAAK,CAAC,gCAAgC,EAAE2B,SAAS,CAAClF,IAAI,CAACwF,MAAM,CAAC;MAC9D;IACF;IAEA,IAAI5F,QAAQ,KAAK,aAAa,EAAE;MAC9BwB,KAAK,CAACgG,SAAS,CAAC5F,IAAI,CAAC;QACnB6F,QAAQ,EAAE,GAAG;QACbzH,QAAQ,EAAE,GAAG;QACbmB,KAAK,EAAEH,IAAI;QACXC;MACF,CAAC,CAAC;MAEF;IACF;IAEA,IAAI;MAAEoB,UAAU,EAAEqF;IAAmB,CAAC,GAAGpC,SAAS;IAClD,IAAIoC,kBAAkB,CAACvD,gBAAgB,CAAC,CAAC,EAAE;MACzC,IAAIuD,kBAAkB,CAACxG,GAAG,CAAC,QAAQ,CAAC,CAACkC,YAAY,CAAC;QAAE5C,IAAI,EAAE;MAAW,CAAC,CAAC,EAAE;QACvEkH,kBAAkB,GAAGA,kBAAkB,CAACrF,UAAW;MACrD;IACF;IAEA,IAAI,CAACqF,kBAAkB,CAACjC,oBAAoB,CAAC,CAAC,EAAE;MAC9C;MACA9B,KAAK,CAAC,8BAA8B,EAAE+D,kBAAkB,CAACtH,IAAI,CAACG,IAAI,CAAC;MACnE;IACF;IAEA,MAAMyD,EAAE,GAAG0D,kBAAkB,CAACxG,GAAG,CAAC,IAAI,CAAC;IACvC,IAAI,CAAC8C,EAAE,CAACZ,YAAY,CAAC,CAAC,EAAE;MACtBO,KAAK,CAAC,4BAA4B,EAAE+D,kBAAkB,CAACtH,IAAI,CAACG,IAAI,CAAC;MACjE;IACF;IAEA,IAAIP,QAAQ,KAAK,UAAU,EAAE;MAC3B,MAAM2H,QAAQ,GAAGrG,qBAAqB,CAAC;QACrCtB,QAAQ,EAAE,GAAG;QACbmB,KAAK,EAAE6C,EAAE;QACT/C,MAAM;QACNV,IAAI,EAAE;MACR,CAAC,CAAC;MACFiB,KAAK,CAACG,OAAO,CAACC,IAAI,CAAC,GAAG+F,QAAQ,CAAC;IACjC,CAAC,MAAM;MACLnG,KAAK,CAACG,OAAO,CAACC,IAAI,CAAC;QACjB5B,QAAQ;QACRmB,KAAK,EAAE6C,EAAE;QACT/C,MAAM;QACNV,IAAI,EAAE;MACR,CAAC,CAAC;IACJ;EACF;EAEA,IAAI+E,SAAS,CAACO,kBAAkB,CAAC,CAAC,EAAE;IAClC;IACA,MAAMC,QAAQ,GAAGR,SAAS,CAACpE,GAAG,CAAC,UAAU,CAAC;IAC1C,IAAI,CAAC4E,QAAQ,CAAC1C,YAAY,CAAC,CAAC,IAAI,CAAC0C,QAAQ,CAACT,eAAe,CAAC,CAAC,EAAE;MAC3D1B,KAAK,CACH,mDAAmD,EACnDmC,QAAQ,CAAC1F,IAAI,CAACG,IAChB,CAAC;MAED;IACF;IAEA,MAAM;MAAE8B,UAAU,EAAEqF;IAAmB,CAAC,GAAGpC,SAAS;IAEpD,IAAIoC,kBAAkB,CAACjC,oBAAoB,CAAC,CAAC,EAAE;MAC7C;MACA,MAAMzB,EAAE,GAAG0D,kBAAkB,CAACxG,GAAG,CAAC,IAAI,CAAC;MACvC,IAAI8C,EAAE,CAACZ,YAAY,CAAC,CAAC,EAAE;QACrB5B,KAAK,CAACG,OAAO,CAACC,IAAI,CAAC;UACjB5B,QAAQ,EAAEG,QAAQ,CAAC2F,QAAQ,CAAC;UAC5B3E,KAAK,EAAE6C,EAAE;UACT/C,MAAM;UACNV,IAAI,EAAE;QACR,CAAC,CAAC;MACJ,CAAC,MAAM;QACLoD,KAAK,CAAC,4BAA4B,EAAE+D,kBAAkB,CAACtH,IAAI,CAACG,IAAI,CAAC;MACnE;IACF,CAAC,MAAM;MACL;MACA;MACAiB,KAAK,CAACG,OAAO,CAACC,IAAI,CAAC;QACjB5B,QAAQ,EAAEG,QAAQ,CAAC2F,QAAQ,CAAC;QAC5B3E,KAAK,EAAEmE,SAAS;QAChBrE,MAAM;QACNV,IAAI,EAAE;MACR,CAAC,CAAC;IACJ;IAEA;EACF;;EAEA;EACA,IAAI4C,GAAG,KAAK,MAAM,IAAImC,SAAS,CAACG,oBAAoB,CAAC,CAAC,EAAE;IACtD3B,4BAA4B,CAACwB,SAAS,EAAE,IAAI,CAAC,CAACzD,OAAO,CAAE6D,IAAI,IAAK;MAC9D,IAAIA,IAAI,CAACnC,IAAI,KAAK,GAAG,EAAE;QACrB,MAAMoE,QAAQ,GAAGrG,qBAAqB,CAAC;UACrCtB,QAAQ,EAAE,GAAG;UACbmB,KAAK,EAAEuE,IAAI,CAAClC,EAAE;UACdvC,MAAM;UACNV,IAAI,EAAE;QACR,CAAC,CAAC;QAEFiB,KAAK,CAACG,OAAO,CAACC,IAAI,CAAC,GAAG+F,QAAQ,CAAC;MACjC,CAAC,MAAM;QACLnG,KAAK,CAACG,OAAO,CAACC,IAAI,CAAC;UACjB5B,QAAQ,EAAE0F,IAAI,CAACnC,IAAI;UACnBpC,KAAK,EAAEuE,IAAI,CAAClC,EAAE;UACdvC,MAAM;UACNV,IAAI,EAAE;QACR,CAAC,CAAC;MACJ;IACF,CAAC,CAAC;EACJ;EAEA,IAAI+E,SAAS,CAACsC,qBAAqB,CAAC,CAAC,EAAE;IACrC;IACApG,KAAK,CAACG,OAAO,CAACC,IAAI,CAAC;MACjB5B,QAAQ,EAAE,aAAa;MACvBmB,KAAK,EAAEmE,SAAS;MAChBrE;IACF,CAAC,CAAC;EACJ;AACF;AAEA,SAAS4G,6BAA6BA,CACpC7G,IAAkC,EAClCQ,KAAkB,EACZ;EACNnB,OAAO,CAACC,GAAG,CAAC,0DAA0D,CAAC;EACvE,IAAIwH,KAAK,GAAG,KAAK;EACjB9G,IAAI,CAACyB,QAAQ,CAAC;IACZC,UAAUA,CAACqF,cAAc,EAAE;MACzB,IAAI,IAAAf,oBAAS,EAACe,cAAc,CAAC,EAAE;QAC7BX,kBAAkB,CAACW,cAAc,EAAEvG,KAAK,CAAC;QACzCsG,KAAK,GAAG,IAAI;MACd;IACF;EACF,CAAC,CAAC;EAEF,IAAIA,KAAK,EAAE;IACT9G,IAAI,CAACgH,IAAI,CAAC,CAAC;EACb;AACF;AAEA,SAASC,uBAAuBA,CAC9BjH,IAAoC,EAC3B;EACTX,OAAO,CAACC,GAAG,CAAC,oDAAoD,CAAC;EACjE,MAAM4H,KAAK,GAAGlH,IAAI,CAACE,GAAG,CAAC,OAAO,CAAC;EAC/B,IAAIgH,KAAK,CAACC,iBAAiB,CAAC;IAAEC,QAAQ,EAAE;EAAO,CAAC,CAAC,EAAE;IACjD,OAAO,IAAI;EACb;EAEA,IAAIF,KAAK,CAACG,sBAAsB,CAAC,CAAC,EAAE;IAClC,OAAOJ,uBAAuB,CAACC,KAAK,CAAC;EACvC;EAEA,OAAO,KAAK;AACd;AAEA,SAASI,cAAcA,CACrBtH,IAA4B,EACM;EAClCX,OAAO,CAACC,GAAG,CAAC,2CAA2C,CAAC;EACxD,IAAIU,IAAI,CAACZ,IAAI,CAACmI,MAAM,CAAC7G,MAAM,KAAK,CAAC,EAAE,OAAOqE,SAAS;EAEnD,MAAMyC,IAAI,GAAGxH,IAAI,CAACE,GAAG,CAAC,MAAM,CAEJ;EACxB,IAAIsH,IAAI,CAAC1D,YAAY,CAAC,CAAC,EAAE;IACvB,OAAO0D,IAAI;EACb;EAEA,IAAIA,IAAI,CAACpI,IAAI,CAACoI,IAAI,CAAC9G,MAAM,KAAK,CAAC,EAAE;IAAA,IAAA+G,SAAA;IAC/B,MAAMC,eAAe,IAAAD,SAAA,GAAGD,IAAI,CAACtH,GAAG,CAAC,MAAM,CAAC,cAAAuH,SAAA,uBAAhBA,SAAA,CAAmB,CAAC,CAAC;IAC7C,IAAI,CAACC,eAAe,CAACC,iBAAiB,CAAC,CAAC,EAAE,OAAO5C,SAAS;IAC1D,MAAMrC,QAAQ,GAAGgF,eAAe,CAACxH,GAAG,CAAC,UAAU,CAAC;IAChD,IAAI,CAACwC,QAAQ,CAACoB,YAAY,CAAC,CAAC,EAAE,OAAOiB,SAAS;IAC9C,OAAOrC,QAAQ;EACjB;EAEA,OAAOqC,SAAS;AAClB;AAEA,SAAS6C,4BAA4BA,CACnCC,UAAsC,EACJ;EAClCxI,OAAO,CAACC,GAAG,CAAC,yDAAyD,CAAC;EACtE,MAAMwI,KAAK,GAAGD,UAAU,CACrB3H,GAAG,CAAC,YAAY,CAAC,CACjB8B,MAAM,CAAC,IAAAC,wBAAW,EAAC,gBAAgB,CAAC,CAAC;EAExC,MAAM8F,MAAM,GAAGD,KAAK,CAACjE,IAAI,CAAElE,CAAC,IAAKA,CAAC,CAACO,GAAG,CAAC,KAAK,CAAC,CAACkC,YAAY,CAAC;IAAE5C,IAAI,EAAE;EAAM,CAAC,CAAC,CAAC;EAC5E,MAAMC,KAAK,GAAGsI,MAAM,aAANA,MAAM,uBAANA,MAAM,CAAE7H,GAAG,CAAC,OAAO,CAAC;EAElC,IAAIT,KAAK,aAALA,KAAK,eAALA,KAAK,CAAE2D,oBAAoB,CAAC,CAAC,IAAI3D,KAAK,aAALA,KAAK,eAALA,KAAK,CAAEuI,yBAAyB,CAAC,CAAC,EAAE;IACvE,OAAOV,cAAc,CAAC7H,KAAK,CAAC;EAC9B;EAEA,MAAMwI,SAAS,GAAGH,KAAK,CAACjE,IAAI,CAAElE,CAAC,IAC7BA,CAAC,CAACO,GAAG,CAAC,KAAK,CAAC,CAACkC,YAAY,CAAC;IAAE5C,IAAI,EAAE;EAAQ,CAAC,CAC7C,CAAC;EAED,MAAM0I,UAAU,GAAGD,SAAS,aAATA,SAAS,uBAATA,SAAS,CAAE/H,GAAG,CAAC,OAAO,CAAC;EAE1C,OAAOgI,UAAU,aAAVA,UAAU,eAAVA,UAAU,CAAEpE,YAAY,CAAC,CAAC,GAAGoE,UAAU,GAAGnD,SAAS;AAC5D;AAEA,SAASoD,SAASA,CAACnI,IAAc,EAAEyG,QAAgB,EAAEjG,KAAkB,EAAQ;EAC7EnB,OAAO,CAACC,GAAG,CAAC,sCAAsC,CAAC;EACnD,SAAS8I,gBAAgBA,CAAA,EAAG;IAC1B/I,OAAO,CAACC,GAAG,CAAC,6CAA6C,CAAC;IAC1D,IAAIU,IAAI,CAAC6E,kBAAkB,CAAC,CAAC,EAAE;MAC7B,MAAMwD,MAAM,GAAGrI,IAAI,CAACE,GAAG,CAAC,QAAQ,CAAC;MACjC,IAAI,CAACmI,MAAM,CAACjG,YAAY,CAAC,CAAC,EAAE;QAC1B,OAAO2C,SAAS;MAClB;MAEA,MAAMuD,aAAa,GAAGD,MAAM,CAACE,KAAK,CAAC9E,UAAU,CAAC4E,MAAM,CAACjJ,IAAI,CAACI,IAAI,CAAC;MAC/D,IAAI,CAAC8I,aAAa,EAAE;QAClB,OAAOvD,SAAS;MAClB;MAEA,IAAIuD,aAAa,CAACtI,IAAI,CAACyE,oBAAoB,CAAC,CAAC,EAAE;QAC7CoC,6BAA6B,CAACyB,aAAa,CAACtI,IAAI,EAAEQ,KAAK,CAAC;MAC1D;MAEA,MAAMsG,KAAK,GAAGtG,KAAK,CAACG,OAAO,CAACkD,IAAI,CAC7B2B,CAAC,IACA8C,aAAa,CAAC3G,UAAU,KAAK6D,CAAC,CAACrF,KAAK,CAACf,IAAI,IACzCkJ,aAAa,CAAC3E,cAAc,CAACuB,IAAI,CAAEvF,CAAC,IAAK6F,CAAC,CAACrF,KAAK,CAACqI,UAAU,CAAC7I,CAAC,CAAC,CAClE,CAAC;MAED,IAAI,CAACmH,KAAK,EAAE;QACV,OAAO/B,SAAS;MAClB;MAEA,MAAMD,QAAQ,GAAG9E,IAAI,CAACE,GAAG,CAAC,UAAU,CAAC;MACrC,IAAIqC,IAAI,GAAG,GAAG;MACd,IAAIvC,IAAI,CAACZ,IAAI,CAACqJ,QAAQ,IAAI3D,QAAQ,CAACT,eAAe,CAAC,CAAC,EAAE;QACpD9B,IAAI,GAAGuC,QAAQ,CAAC1F,IAAI,CAACK,KAAK;MAC5B,CAAC,MAAM,IAAI,CAACO,IAAI,CAACZ,IAAI,CAACqJ,QAAQ,IAAI3D,QAAQ,CAAC1C,YAAY,CAAC,CAAC,EAAE;QACzDG,IAAI,GAAGuC,QAAQ,CAAC1F,IAAI,CAACI,IAAI;MAC3B;MAEA,OAAO;QACLkJ,MAAM,EAAE;UAAE,GAAG5B,KAAK;UAAE3G,KAAK,EAAEH;QAAK,CAAC;QACjCuC;MACF,CAAC;IACH;IAEA,OAAOwC,SAAS;EAClB;EAEA,MAAM4D,aAAa,GAAGP,gBAAgB,CAAC,CAAC;EACxC,IAAIO,aAAa,EAAE;IACjB;IACAnI,KAAK,CAACgG,SAAS,CAAC5F,IAAI,CAAC;MACnBT,KAAK,EAAEwI,aAAa,CAACD,MAAM,CAACvI,KAAK;MACjCnB,QAAQ,EAAE2J,aAAa,CAACD,MAAM,CAAC1J,QAAQ;MACvCiB,MAAM,EAAE0I,aAAa,CAACD,MAAM,CAACzI,MAAM;MACnCwG;IACF,CAAC,CAAC;EACJ,CAAC,MAAM;IACL;IACAjG,KAAK,CAACvB,OAAO,CAACwH,QAAQ,CAAC,GAAGzG,IAAI;EAChC;AACF;AAEA,MAAM4I,OAAO,GAAGA,CACdpI,KAAkB,EAClBqI,UAAkB,EAClBC,gBAA4C,KACzC;EACHzJ,OAAO,CAACC,GAAG,CAAC,oCAAoC,CAAC;EACjD;EACA,IAAI,CAACkB,KAAK,CAACuI,UAAU,CAACzC,GAAG,CAACuC,UAAU,CAAC,EAAE;IACrCrI,KAAK,CAACuI,UAAU,CAACC,GAAG,CAACH,UAAU,EAAE,EAAE,CAAC;EACtC;EAEArI,KAAK,CAACuI,UAAU,CAAC7I,GAAG,CAAC2I,UAAU,CAAC,CAAEjI,IAAI,CAACkI,gBAAgB,CAAC;AAC1D,CAAC;AAED,SAASG,kBAAkBA,CACzBjJ,IAA0B,EAC1BQ,KAAkB,EACZ;EACNnB,OAAO,CAACC,GAAG,CAAC,+CAA+C,CAAC;EAC5D,IAAI,CAAC,IAAAqG,oBAAS,EAAC3F,IAAI,CAAC,EAAE;EAEtB,IAAIA,IAAI,CAACqB,UAAU,CAACwD,kBAAkB,CAAC;IAAEwD,MAAM,EAAErI,IAAI,CAACZ;EAAK,CAAC,CAAC,EAAE;IAC7D;IACA,MAAM0J,gBAAgB,GAAG9I,IAAI,CAACqB,UAAU;IACxC,MAAMyD,QAAQ,GAAGgE,gBAAgB,CAAC5I,GAAG,CAAC,UAAU,CAAC;IACjD,IAAI,CAAC4E,QAAQ,CAAC1C,YAAY,CAAC,CAAC,IAAI0G,gBAAgB,CAAC1J,IAAI,CAACqJ,QAAQ,EAAE;MAC9D;IACF;IAEA,MAAMI,UAAU,GAAG/D,QAAQ,CAAC1F,IAAI,CAACI,IAAI;IAErC,MAAM0J,oBAAoB,GAAGJ,gBAAgB,CAACzH,UAAU;IAExD,IACE,CAAC6H,oBAAoB,CAAC7B,sBAAsB,CAAC;MAC3C8B,IAAI,EAAEL,gBAAgB,CAAC1J;IACzB,CAAC,CAAC,EACF;MACA;MACAwJ,OAAO,CAACpI,KAAK,EAAEqI,UAAU,EAAEC,gBAAgB,CAAC;MAC5C;IACF;IAEA,MAAM5B,KAAK,GAAGgC,oBAAoB,CAAChJ,GAAG,CAAC,OAAO,CAAC;IAE/C,IAAI+G,uBAAuB,CAACiC,oBAAoB,CAAC,EAAE;MACjD;MACA;IACF;IAEA,IAAIL,UAAU,KAAK,YAAY,EAAE;MAC/B;MACArI,KAAK,CAAC4I,UAAU,GAAG,IAAI;MACvB;IACF;IAEAR,OAAO,CAACpI,KAAK,EAAEqI,UAAU,EAAEC,gBAAgB,CAAC;IAC5C;IACAtI,KAAK,CAACvB,OAAO,CAAC6F,QAAQ,CAAC1F,IAAI,CAACI,IAAI,CAAC,GAAG0H,KAAK;IAEzC;EACF;EAEA,IACElH,IAAI,CAACqB,UAAU,CAAC8B,gBAAgB,CAAC,CAAC,IAClCnD,IAAI,CAACqB,UAAU,CAACnB,GAAG,CAAC,QAAQ,CAAC,CAACmJ,cAAc,CAAC,uBAAuB,CAAC,EACrE;IACA,MAAM,CAACC,GAAG,EAAE5E,IAAI,EAAEmD,UAAU,CAAC,GAAG7H,IAAI,CAACqB,UAAU,CAACnB,GAAG,CAAC,WAAW,CAAC;IAChE,IACEoJ,GAAG,aAAHA,GAAG,eAAHA,GAAG,CAAElH,YAAY,CAACpC,IAAI,CAACZ,IAAI,CAAC,IAC5BsF,IAAI,aAAJA,IAAI,eAAJA,IAAI,CAAEL,eAAe,CAAC,CAAC,IACvBwD,UAAU,aAAVA,UAAU,eAAVA,UAAU,CAAE5B,kBAAkB,CAAC,CAAC,EAChC;MACA,IAAIvB,IAAI,CAACtF,IAAI,CAACK,KAAK,KAAK,YAAY,EAAE;QACpC;QACAe,KAAK,CAAC4I,UAAU,GAAG,IAAI;MACzB,CAAC,MAAM;QACL;AACR;AACA;AACA;AACA;AACA;AACA;AACA;QACQ,MAAM3C,QAAQ,GAAG/B,IAAI,CAACtF,IAAI,CAACK,KAAK;QAChC,MAAMU,KAAK,GAAGyH,4BAA4B,CAACC,UAAU,CAAC;QACtD,IAAI1H,KAAK,EAAE;UACTgI,SAAS,CAAChI,KAAK,EAAEsG,QAAQ,EAAEjG,KAAK,CAAC;QACnC;MACF;IACF,CAAC,MAAM,IACL8I,GAAG,aAAHA,GAAG,eAAHA,GAAG,CAAElH,YAAY,CAACpC,IAAI,CAACZ,IAAI,CAAC,IAC5BsF,IAAI,aAAJA,IAAI,eAAJA,IAAI,CAAEtC,YAAY,CAAC,CAAC,IACpByF,UAAU,aAAVA,UAAU,eAAVA,UAAU,CAAE5B,kBAAkB,CAAC,CAAC,EAChC;MACA;AACN;AACA;AACA;AACA;AACA;AACA;AACA;MACM,MAAM9F,KAAK,GAAGyH,4BAA4B,CAACC,UAAU,CAAC;MACtD,IAAI1H,KAAK,EAAE;QACTgI,SAAS,CAAChI,KAAK,EAAE,GAAG,EAAEK,KAAK,CAAC;MAC9B;IACF;EACF;AACF;AAEA,SAAS+I,2BAA2BA,CAClCvJ,IAA0B,EAC1BQ,KAAkB,EACZ;EACNnB,OAAO,CAACC,GAAG,CAAC,wDAAwD,CAAC;EACrE,IAAI,IAAA0G,oBAAS,EAAChG,IAAI,CAAC,EAAE;IACnBoG,kBAAkB,CAACpG,IAAI,EAAEQ,KAAK,CAAC;EACjC,CAAC,MAAM,IAAI,IAAAmF,oBAAS,EAAC3F,IAAI,CAAC,EAAE;IAC1BiJ,kBAAkB,CAACjJ,IAAI,EAAEQ,KAAK,CAAC;EACjC;AACF;AAEA,SAASF,qBAAqBA,CAC5BkJ,UAAuC,EAC5B;EACXnK,OAAO,CAACC,GAAG,CAAC,kDAAkD,CAAC;EAC/D,MAAM6B,MAAiB,GAAG,EAAE;EAC5B,MAAM;IAAEhB;EAAM,CAAC,GAAGqJ,UAAU;EAC5B,IAAI,CAACrJ,KAAK,CAACiC,YAAY,CAAC,CAAC,EAAE;IACzB;IACA,OAAO,CAACoH,UAAU,CAAC;EACrB;EAEA,MAAMjG,OAAO,GAAG,IAAAC,kBAAQ,EAACrD,KAAK,CAAC,CAACsD,UAAU,CAACtD,KAAK,CAACf,IAAI,CAACI,IAAI,CAAC;EAC3D,IAAI,EAAC+D,OAAO,aAAPA,OAAO,eAAPA,OAAO,CAAEkG,UAAU,GAAE;IACxB;IACA;IACA,OAAO,CACL;MACE,GAAGD,UAAU;MACbxK,QAAQ,EAAE;IACZ,CAAC,CACF;EACH;EAEA,KAAK,MAAM0K,aAAa,KAAAC,qBAAA,GAAIpG,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAEI,cAAc,cAAAgG,qBAAA,cAAAA,qBAAA,GAAI,EAAE,EAAE;IAAA,IAAAA,qBAAA;IACzD,IACED,aAAa,CAAC7F,IAAI,CACf+F,QAAQ,IAAKA,QAAQ,CAACC,QAAQ,CAAC,CAAC,IAAID,QAAQ,CAACE,UAAU,CAAC,CAC3D,CAAC,EACD;MACA;IACF;IAEA,MAAM;MAAEzI;IAAW,CAAC,GAAGqI,aAAa;IACpC,IAAIrI,UAAU,aAAVA,UAAU,eAAVA,UAAU,CAAEwD,kBAAkB,CAAC,CAAC,IAAI6E,aAAa,CAACvH,GAAG,KAAK,QAAQ,EAAE;MACtE,MAAM2C,QAAQ,GAAGzD,UAAU,CAACnB,GAAG,CAAC,UAAU,CAAC;MAC3C,MAAMmI,MAAM,GAAGhH,UAAU,CAACnB,GAAG,CAAC,QAAQ,CAAC;MACvC,IAAIlB,QAAuB;MAC3B,IAAIqC,UAAU,CAACjC,IAAI,CAACqJ,QAAQ,IAAI3D,QAAQ,CAACT,eAAe,CAAC,CAAC,EAAE;QAC1DrF,QAAQ,GAAG8F,QAAQ,CAAC1F,IAAI,CAACK,KAAK;MAChC,CAAC,MAAM,IAAI,CAAC4B,UAAU,CAACjC,IAAI,CAACqJ,QAAQ,IAAI3D,QAAQ,CAAC1C,YAAY,CAAC,CAAC,EAAE;QAC/DpD,QAAQ,GAAG8F,QAAQ,CAAC1F,IAAI,CAACI,IAAI;MAC/B,CAAC,MAAM;QACLR,QAAQ,GAAG,IAAI;MACjB;MAEA,IAAIqJ,MAAM,CAACjG,YAAY,CAAC,CAAC,IAAIpD,QAAQ,EAAE;QACrCmC,MAAM,CAACP,IAAI,CAAC;UACV,GAAG4I,UAAU;UACbxK,QAAQ;UACRmB,KAAK,EAAEkB;QACT,CAAC,CAAC;MACJ,CAAC,MAAM;QACLF,MAAM,CAACP,IAAI,CAAC4I,UAAU,CAAC;QACvB;MACF;MAEA;IACF;IAEA,IAAInI,UAAU,aAAVA,UAAU,eAAVA,UAAU,CAAEoD,oBAAoB,CAAC,CAAC,IAAIiF,aAAa,CAACvH,GAAG,KAAK,MAAM,EAAE;MACtEW,4BAA4B,CAACzB,UAAU,EAAE,IAAI,CAAC,CAACa,GAAG,CAAEwC,IAAI,IACtDvD,MAAM,CAACP,IAAI,CAAC;QAAE,GAAG4I,UAAU;QAAExK,QAAQ,EAAE0F,IAAI,CAACnC,IAAI;QAAEpC,KAAK,EAAEuE,IAAI,CAAClC;MAAG,CAAC,CACpE,CAAC;MAED;IACF;IAEA,IACEnB,UAAU,aAAVA,UAAU,eAAVA,UAAU,CAAE8B,gBAAgB,CAAC,CAAC,IAC9BuG,aAAa,CAACK,OAAO,KAAK,WAAW,EACrC;MACA;MACA,MAAMC,UAAU,GAAGvE,oCAAoC,CACrDpE,UAAU,EACVqI,aACF,CAAC;MAED,IAAI,CAACM,UAAU,EAAE;QACf;QACA;QACA7I,MAAM,CAACP,IAAI,CAAC4I,UAAU,CAAC;QACvB;MACF;MAEA,IAAIQ,UAAU,KAAK,SAAS,EAAE;QAC5B7I,MAAM,CAACP,IAAI,CAAC;UACV,GAAG4I,UAAU;UACbxK,QAAQ,EAAE,SAAS;UACnBmB,KAAK,EAAEkB,UAAU,CAACnB,GAAG,CAAC,IAAI;QAC5B,CAAC,CAAC;QAEF;MACF;MAEA,IAAI8J,UAAU,KAAK,UAAU,EAAE;QAC7B7I,MAAM,CAACP,IAAI,CAAC4I,UAAU,CAAC;QACvB;MACF;MAEA7G,KAAK,CAAC,gDAAgD,EAAEqH,UAAU,CAAC;MAEnE7I,MAAM,CAACP,IAAI,CAAC4I,UAAU,CAAC;MACvB;IACF;IAEA,IACEnI,UAAU,aAAVA,UAAU,eAAVA,UAAU,CAAE4I,iBAAiB,CAAC,CAAC,IAC/B5I,UAAU,aAAVA,UAAU,eAAVA,UAAU,CAAE6I,0BAA0B,CAAC,CAAC,EACxC;MACA;MACA/I,MAAM,CAACP,IAAI,CAAC4I,UAAU,CAAC;MACvB;IACF;;IAEA;IACA;IACA7G,KAAK,CACH,8CAA8C,EAC9C+G,aAAa,CAACtK,IAAI,CAACG,IACrB,CAAC;IACD4B,MAAM,CAACP,IAAI,CAAC4I,UAAU,CAAC;IACvB;EACF;EAEA,OAAOrI,MAAM;AACf;AAEA,SAASgJ,+BAA+BA,CACtCnK,IAAoC,EACpCQ,KAAkB,EACZ;EAAA,IAAA4J,SAAA;EACN/K,OAAO,CAACC,GAAG,CAAC,4DAA4D,CAAC;EACzE,IAAII,MAAM,CAACM,IAAI,CAAC,EAAE;EAClB,MAAMC,MAAM,IAAAmK,SAAA,GAAGpK,IAAI,CAACE,GAAG,CAAC,QAAQ,CAAC,cAAAkK,SAAA,gBAAAA,SAAA,GAAlBA,SAAA,CAAoBhL,IAAI,cAAAgL,SAAA,uBAAxBA,SAAA,CAA0B3K,KAAK;EAC9C,IAAI,CAACQ,MAAM,EAAE;;EAEb;EACAO,KAAK,CAACgG,SAAS,CAAC5F,IAAI,CAAC;IACnB6F,QAAQ,EAAE,GAAG;IACbzH,QAAQ,EAAE,GAAG;IACbmB,KAAK,EAAEH,IAAI;IACXC;EACF,CAAC,CAAC;AACJ;AAEA,SAASoK,0BAA0BA,CACjCrK,IAEC,EACDC,MAA0B,EAC1BO,KAAkB,EACZ;EACNnB,OAAO,CAACC,GAAG,CAAC,uDAAuD,CAAC;EACpE,IAAIU,IAAI,CAACiK,iBAAiB,CAAC,CAAC,EAAE;IAC5B,MAAMxD,QAAQ,GAAGtH,QAAQ,CAACa,IAAI,CAACE,GAAG,CAAC,UAAU,CAAC,CAAC;IAC/C,IAAID,MAAM,EAAE;MACV;MACA,MAAMjB,QAAQ,GAAGgB,IAAI,CAACE,GAAG,CAAC,OAAO,CAAC,CAACd,IAAI,CAACI,IAAI;MAC5CgB,KAAK,CAACgG,SAAS,CAAC5F,IAAI,CAAC;QACnB6F,QAAQ;QACRzH,QAAQ;QACRmB,KAAK,EAAEH,IAAI;QACXC;MACF,CAAC,CAAC;IACJ,CAAC,MAAM;MACL,MAAME,KAAK,GAAGH,IAAI,CAACE,GAAG,CAAC,OAAO,CAAC;MAC/B;MACAM,KAAK,CAACvB,OAAO,CAACwH,QAAQ,CAAC,GAAGtG,KAAK;IACjC;IAEA;EACF;EAEA,IAAIH,IAAI,CAACsK,wBAAwB,CAAC,CAAC,IAAIrK,MAAM,EAAE;IAC7C;IACAO,KAAK,CAACgG,SAAS,CAAC5F,IAAI,CAAC;MACnB6F,QAAQ,EAAE,SAAS;MACnBzH,QAAQ,EAAE,SAAS;MACnBmB,KAAK,EAAEH,IAAI;MACXC;IACF,CAAC,CAAC;EACJ;EAEA,IAAID,IAAI,CAACuK,0BAA0B,CAAC,CAAC,IAAItK,MAAM,EAAE;IAC/C,MAAMwG,QAAQ,GAAGzG,IAAI,CAACE,GAAG,CAAC,UAAU,CAAC,CAACd,IAAI,CAACI,IAAI;IAC/C;IACAgB,KAAK,CAACgG,SAAS,CAAC5F,IAAI,CAAC;MACnB6F,QAAQ;MACRzH,QAAQ,EAAE,GAAG;MACbmB,KAAK,EAAEH,IAAI;MACXC;IACF,CAAC,CAAC;EACJ;;EAEA;EACA0C,KAAK,CACH,4DAA4D,EAC5D3C,IAAI,CAACZ,IAAI,CAACG,IACZ,CAAC;AACH;AAEA,SAASiL,iCAAiCA,CACxCxK,IAAsC,EACtCQ,KAAkB,EACZ;EAAA,IAAAiK,UAAA;EACNpL,OAAO,CAACC,GAAG,CAAC,8DAA8D,CAAC;EAC3E,IAAII,MAAM,CAACM,IAAI,CAAC,EAAE;EAElB,MAAMC,MAAM,IAAAwK,UAAA,GAAGzK,IAAI,CAACE,GAAG,CAAC,QAAQ,CAAC,cAAAuK,UAAA,gBAAAA,UAAA,GAAlBA,UAAA,CAAoBrL,IAAI,cAAAqL,UAAA,uBAAxBA,UAAA,CAA0BhL,KAAK;EAC9C,MAAMgB,UAAU,GAAGT,IAAI,CAACE,GAAG,CAAC,YAAY,CAAC;EACzC,IAAIO,UAAU,EAAE;IACdA,UAAU,CAACI,OAAO,CAAEC,SAAS,IAC3BuJ,0BAA0B,CAACvJ,SAAS,EAAEb,MAAM,EAAEO,KAAK,CACrD,CAAC;EACH;EAEA,MAAMkK,WAAW,GAAG1K,IAAI,CAACE,GAAG,CAAC,aAAa,CAAC;EAC3C,IAAIwK,WAAW,CAACC,qBAAqB,CAAC,CAAC,EAAE;IACvCD,WAAW,CAACxK,GAAG,CAAC,cAAc,CAAC,CAACW,OAAO,CAAE+J,UAAU,IAAK;MACtD;MACApK,KAAK,CAACvB,OAAO,GAAG;QACd,GAAGuB,KAAK,CAACvB,OAAO;QAChB,GAAGoE,4BAA4B,CAACuH,UAAU;MAC5C,CAAC;IACH,CAAC,CAAC;EACJ;EAEA,IAAIF,WAAW,CAACG,mBAAmB,CAAC,CAAC,EAAE;IACrC;IACArK,KAAK,CAACvB,OAAO,CAACyL,WAAW,CAACxK,GAAG,CAAC,IAAI,CAAC,CAACd,IAAI,CAACI,IAAI,CAAC,GAAGkL,WAAW;EAC9D;EAEA,IAAIA,WAAW,CAACI,qBAAqB,CAAC,CAAC,EAAE;IACvC,MAAM9H,EAAE,GAAG0H,WAAW,CAACxK,GAAG,CAAC,IAAI,CAAC;IAChC,IAAI8C,EAAE,CAACZ,YAAY,CAAC,CAAC,EAAE;MACrB;MACA5B,KAAK,CAACvB,OAAO,CAAC+D,EAAE,CAAC5D,IAAI,CAACI,IAAI,CAAC,GAAGwD,EAAE;IAClC;EACF;EAEA,IAAI0H,WAAW,CAACK,kBAAkB,CAAC,CAAC,EAAE;IACpC,MAAM/H,EAAE,GAAG0H,WAAW,CAACxK,GAAG,CAAC,IAAI,CAAC;IAChC,IAAI8C,EAAE,CAACZ,YAAY,CAAC,CAAC,EAAE;MACrB;MACA5B,KAAK,CAACvB,OAAO,CAAC+D,EAAE,CAAC5D,IAAI,CAACI,IAAI,CAAC,GAAGwD,EAAE;IAClC;EACF;AACF;AAEA,SAASgI,mCAAmCA,CAC1ChL,IAAwC,EACxCQ,KAAkB,EACZ;EACNnB,OAAO,CAACC,GAAG,CAAC,gEAAgE,CAAC;EAC7E,IAAII,MAAM,CAACM,IAAI,CAAC,EAAE;;EAElB;EACAQ,KAAK,CAACvB,OAAO,CAACgM,OAAO,GAAGjL,IAAI,CAACE,GAAG,CAAC,aAAa,CAAC;AACjD;AAEA,SAASgL,+BAA+BA,CACtClL,IAAoC,EACpCQ,KAAkB,EACZ;EAAA,IAAA2K,UAAA;EACN9L,OAAO,CAACC,GAAG,CAAC,4DAA4D,CAAC;EACzE,IAAI2H,uBAAuB,CAACjH,IAAI,CAAC,EAAE;IACjC;EACF;EAEA,MAAMmJ,IAAI,GAAGnJ,IAAI,CAACE,GAAG,CAAC,MAAM,CAAC;EAC7B,MAAMgH,KAAK,GAAGlH,IAAI,CAACE,GAAG,CAAC,OAAO,CAAC;EAE/B,IAAIuG,QAA2C;EAE/C,MAAM2E,WAAW,GACfjC,IAAI,CAACtE,kBAAkB,CAAC,CAAC,IAAI,IAAAc,oBAAS,EAACwD,IAAI,CAACjJ,GAAG,CAAC,QAAQ,CAAC,CAAC;EAC5D,IAAIkL,WAAW,EAAE;IACf,MAAMtG,QAAQ,GAAGqE,IAAI,CAACjJ,GAAG,CAAC,UAAU,CAAC;IACrC,IAAI,CAACiJ,IAAI,CAAC/J,IAAI,CAACqJ,QAAQ,IAAI3D,QAAQ,CAAC1C,YAAY,CAAC,CAAC,EAAE;MAClDqE,QAAQ,GAAG3B,QAAQ,CAAC1F,IAAI,CAACI,IAAI;IAC/B,CAAC,MAAM,IAAI2J,IAAI,CAAC/J,IAAI,CAACqJ,QAAQ,IAAI3D,QAAQ,CAACT,eAAe,CAAC,CAAC,EAAE;MAC3DoC,QAAQ,GAAG3B,QAAQ,CAAC1F,IAAI,CAACK,KAAK;IAChC;EACF,CAAC,MAAM,IAAI,IAAAkG,oBAAS,EAACwD,IAAI,CAAC,EAAE;IAC1B;IACA,IAAI,CAACrD,kBAAkB,CAACoB,KAAK,CAAC,EAAE;MAC9BT,QAAQ,GAAG,SAAS;IACtB;EACF;EAEA,IAAI,CAACA,QAAQ,EAAE;EAEf,IAAIA,QAAQ,KAAK,YAAY,EAAE;IAC7B;IACAjG,KAAK,CAAC4I,UAAU,GAAG,IAAI;IACvB;EACF;EAEA,IAAI,CAACrD,aAAa,CAACmB,KAAK,CAAC,EAAE;IACzB,MAAMyB,aAAa,GAAGnI,KAAK,CAACG,OAAO,CAACkD,IAAI,CAAEwH,GAAG,IAAKA,GAAG,CAAClL,KAAK,KAAK+G,KAAK,CAAC;IACtE,IAAIyB,aAAa,EAAE;MACjBnI,KAAK,CAACgG,SAAS,CAAC5F,IAAI,CAAC;QACnB6F,QAAQ;QACR,GAAGkC;MACL,CAAC,CAAC;IACJ,CAAC,MAAM;MACL;MACAnI,KAAK,CAACvB,OAAO,CAACwH,QAAQ,CAAC,GAAGS,KAAK;IACjC;IAEA,IAAIkE,WAAW,EAAE;MACfxC,OAAO,CAACpI,KAAK,EAAEiG,QAAQ,EAAE0C,IAAI,CAAC;IAChC;IAEAnJ,IAAI,CAACgH,IAAI,CAAC,CAAC;IACX;EACF;EAEA,MAAM5C,UAAU,IAAA+G,UAAA,GAAGjE,KAAK,CAAChH,GAAG,CAAC,WAAW,CAAC,cAAAiL,UAAA,uBAAtBA,UAAA,CAAyB,CAAC,CAAC;EAC9C,MAAMlL,MAAM,GAAGmE,UAAU,CAACC,eAAe,CAAC,CAAC,GACvCD,UAAU,CAAChF,IAAI,CAACK,KAAK,GACrBsF,SAAS;EACb,IAAI,CAAC9E,MAAM,EAAE;;EAEb;;EAEA,IAAIO,KAAK,CAACvB,OAAO,CAACwH,QAAQ,CAAC,EAAE;IAC3B;IACA,OAAOjG,KAAK,CAACvB,OAAO,CAACwH,QAAQ,CAAC;EAChC;EAEAjG,KAAK,CAACgG,SAAS,CAAC5F,IAAI,CAAC;IACnB6F,QAAQ;IACRzH,QAAQ,EAAE,GAAG;IACbmB,KAAK,EAAEH,IAAI;IACXC;EACF,CAAC,CAAC;EAEFD,IAAI,CAACgH,IAAI,CAAC,CAAC;AACb;AAEA,SAASsE,kBAAkBA,CACzBtL,IAA8B,EAC9BzB,OAA0B,EAC1BiC,KAAkB,EAClB;EAAA,IAAA+K,gBAAA;EACAlM,OAAO,CAACC,GAAG,CAAC,+CAA+C,CAAC;EAC5D,MAAMkM,WAAW,GACf,OAAOjN,OAAO,KAAK,QAAQ,GAAGyB,IAAI,CAACE,GAAG,CAAC,WAAW,CAAC,CAAC3B,OAAO,CAAC,GAAGA,OAAO;EACxE,IAAI,CAACiN,WAAW,CAACrI,gBAAgB,CAAC,CAAC,EAAE;EACrC,MAAMyB,MAAM,GAAG4G,WAAW,CAACtL,GAAG,CAAC,QAAQ,CAAC;EACxC,MAAMkE,UAAU,IAAAmH,gBAAA,GAAGC,WAAW,CAACtL,GAAG,CAAC,WAAW,CAAC,cAAAqL,gBAAA,uBAA5BA,gBAAA,CAA+B,CAAC,CAAC;EACpD,IAAI,CAAC,IAAAvF,oBAAS,EAACpB,MAAM,CAAC,IAAI,CAACR,UAAU,CAACC,eAAe,CAAC,CAAC,EAAE;EAEzD,MAAMpE,MAAM,GAAGmE,UAAU,CAAChF,IAAI,CAACK,KAAK;EACpC,IAAI,CAACQ,MAAM,EAAE;EAEbO,KAAK,CAACgG,SAAS,CAAC5F,IAAI,CAAC;IACnB6F,QAAQ,EAAE,GAAG;IACbzH,QAAQ,EAAE,GAAG;IACbmB,KAAK,EAAEH,IAAI;IACXC;EACF,CAAC,CAAC;EAEFD,IAAI,CAACgH,IAAI,CAAC,CAAC;AACb;AAEA,SAASyE,cAAcA,CAACvJ,GAA+B,EAAE1B,KAAkB,EAAE;EAC3EnB,OAAO,CAACC,GAAG,CAAC,2CAA2C,CAAC;EACxD,MAAM4G,UAAU,GAAGhE,GAAG,CAAChC,GAAG,CAAC,YAAY,CAAC;EACxCgG,UAAU,CAACrF,OAAO,CAAEiE,QAAQ,IAAK;IAC/B,IAAI,CAACA,QAAQ,CAAChD,gBAAgB,CAAC,CAAC,EAAE;IAClC,MAAMK,GAAG,GAAG2C,QAAQ,CAAC5E,GAAG,CAAC,KAAK,CAAC;IAC/B,MAAMT,KAAK,GAAGqF,QAAQ,CAAC5E,GAAG,CAAC,OAAO,CAAC;IACnC,IAAI,CAACiC,GAAG,CAACC,YAAY,CAAC,CAAC,EAAE;IACzB,MAAMqE,QAAQ,GAAGtE,GAAG,CAAC/C,IAAI,CAACI,IAAI;IAE9B,IAAI,CAACC,KAAK,CAACiM,UAAU,CAAC,CAAC,EAAE;IACzB,IAAIjM,KAAK,CAACL,IAAI,CAACmI,MAAM,CAAC7G,MAAM,KAAK,CAAC,EAAE;IAEpC,MAAMiL,WAAW,GAAGrE,cAAc,CAAC7H,KAAK,CAAC;IACzC,IAAI,CAACkM,WAAW,EAAE;IAElBxD,SAAS,CAACwD,WAAW,EAAElF,QAAQ,EAAEjG,KAAK,CAAC;EACzC,CAAC,CAAC;AACJ;AAEA,SAASoL,kBAAkBA,CACzB5L,IAA8B,EAC9B6L,WAAmB,EACnBrL,KAAkB,EAClB;EACAnB,OAAO,CAACC,GAAG,CAAC,+CAA+C,CAAC;EAC5D,MAAM4C,GAAG,GAAGlC,IAAI,CAACE,GAAG,CAAC,WAAW,CAAC,CAAC2L,WAAW,CAAC;EAC9C,IAAI,CAAC3J,GAAG,CAAC+D,kBAAkB,CAAC,CAAC,EAAE;EAE/BwF,cAAc,CAACvJ,GAAG,EAAE1B,KAAK,CAAC;EAE1BR,IAAI,CAACgH,IAAI,CAAC,CAAC;AACb;AAEA,SAAS8E,8BAA8BA,CACrC9L,IAA8B,EAC9BQ,KAAkB,EAClB;EAAA,IAAAuL,iBAAA;EACA1M,OAAO,CAACC,GAAG,CAAC,2DAA2D,CAAC;EACxE,MAAM,CAAC0M,aAAa,EAAEC,QAAQ,EAAEhN,OAAO,CAAC,GAAGe,IAAI,CAACE,GAAG,CAAC,WAAW,CAAC;EAChE,IACE,CAAC8L,aAAa,CAAC5J,YAAY,CAAC;IAAE5C,IAAI,EAAE;EAAiB,CAAC,CAAC,IACvD,CAAC,IAAAmG,oBAAS,EAACqG,aAAa,CAAC,EAEzB;EACF,IAAI,CAACC,QAAQ,CAAC9I,gBAAgB,CAAC,CAAC,EAAE;EAElC,IAAIqI,WAAW,GAAGS,QAAQ;EAC1B,OAAO,CAAC,IAAAjG,oBAAS,EAACwF,WAAW,CAACtL,GAAG,CAAC,QAAQ,CAAC,CAAC,EAAE;IAC5C,MAAMkF,IAAI,GAAGoG,WAAW,CAACtL,GAAG,CAAC,WAAW,CAAC;IACzC,IAAIkF,IAAI,CAAC1E,MAAM,KAAK,CAAC,EAAE;MACrB;IACF;IAEA,MAAMwL,QAAQ,GAAG9G,IAAI,CAAC,CAAC,CAAC;IACxB,IAAI,CAAC8G,QAAQ,CAAC/I,gBAAgB,CAAC,CAAC,EAAE;MAChC;IACF;IAEAqI,WAAW,GAAGU,QAAQ;EACxB;EAEA,IAAIjN,OAAO,KAAK8F,SAAS,IAAI,CAAC,IAAAY,oBAAS,EAAC1G,OAAO,CAAC,EAAE;EAElD,MAAMmF,UAAU,IAAA2H,iBAAA,GAAGP,WAAW,CAACtL,GAAG,CAAC,WAAW,CAAC,cAAA6L,iBAAA,uBAA5BA,iBAAA,CAA+B,CAAC,CAAC;EACpD,IAAI,CAAC3H,UAAU,CAACC,eAAe,CAAC,CAAC,EAAE;EAEnC7D,KAAK,CAACgG,SAAS,CAAC5F,IAAI,CAAC;IACnB6F,QAAQ,EAAE,GAAG;IACbzH,QAAQ,EAAE,GAAG;IACbmB,KAAK,EAAEH,IAAI;IACXC,MAAM,EAAEmE,UAAU,CAAChF,IAAI,CAACK;EAC1B,CAAC,CAAC;EAEFO,IAAI,CAACgH,IAAI,CAAC,CAAC;AACb;AAEA,SAASmF,yBAAyBA,CAChCnM,IAA8B,EAC9BQ,KAAkB,EAClB;EACAnB,OAAO,CAACC,GAAG,CAAC,sDAAsD,CAAC;EACnE,MAAM8M,gBAAgB,GAAGpM,IAAI,CAACE,GAAG,CAAC,QAAQ,CAAC;EAC3C,IAAI,CAACkM,gBAAgB,CAAChK,YAAY,CAAC,CAAC,EAAE;IACpC;EACF;EAEA,IACE4C,SAAS,CAAChF,IAAI,EAAE,CACd,CAAC,cAAc,EAAE2F,oBAAS,EAAExC,gBAAgB,CAAC,YAAY,CAAC,CAAC,CAC5D,CAAC,EACF;IACA;;IAEA,MAAMkJ,SAAS,GAAGrM,IAAI,CAACE,GAAG,CAAC,WAAW,CAAC,CAAC,CAAC,CAA6B;IACtEoL,kBAAkB,CAACtL,IAAI,EAAEqM,SAAS,CAACnM,GAAG,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,EAAEM,KAAK,CAAC;IAC9D;EACF;;EAEA;EACA,IACEwE,SAAS,CAAChF,IAAI,EAAE,CACd,CAAC,eAAe,EAAE+F,aAAa,EAAEJ,oBAAS,CAAC,EAC3C,CAAC,aAAa,EAAEI,aAAa,EAAEJ,oBAAS,CAAC,EACzC,CAAC,cAAc,EAAEI,aAAa,EAAEJ,oBAAS,CAAC,EAC1C,CAAC,UAAU,EAAEI,aAAa,CAAC,CAAE;EAAA,CAC9B,CAAC,EACF;IACAuF,kBAAkB,CAACtL,IAAI,EAAE,CAAC,EAAEQ,KAAK,CAAC;IAClC;EACF;EAEA,IAAIwE,SAAS,CAAChF,IAAI,EAAE,CAAC,CAAC,SAAS,EAAE2F,oBAAS,EAAEM,kBAAkB,CAAC,CAAC,CAAC,EAAE;IACjE2F,kBAAkB,CAAC5L,IAAI,EAAE,CAAC,EAAEQ,KAAK,CAAC;IAClC;EACF;EAEA,IACEwE,SAAS,CAAChF,IAAI,EAAE,CACd,CAAC,UAAU,EAAE4F,aAAa,EAAEG,aAAa,CAAC,CAAE;EAAA,CAC7C,CAAC,EACF;IACAuF,kBAAkB,CAACtL,IAAI,EAAE,CAAC,EAAEQ,KAAK,CAAC;IAClC;EACF;;EAEA;EACA,IACEwE,SAAS,CAAChF,IAAI,EAAE,CACd,CAAC,UAAU,EAAE2F,oBAAS,EAAEM,kBAAkB,CAAC,EAC3C,CAAC,UAAU,EAAE7D,YAAY,CAAC,gBAAgB,CAAC,EAAE6D,kBAAkB,CAAC,CACjE,CAAC,EACF;IACA2F,kBAAkB,CAAC5L,IAAI,EAAE,CAAC,EAAEQ,KAAK,CAAC;IAClC;EACF;EAEA,IACEwE,SAAS,CAAChF,IAAI,EAAE;EACd;EACA,CACE,YAAY,EACZoC,YAAY,CAAC,gBAAgB,CAAC,EAC9Be,gBAAgB,EAChBwC,oBAAS,CACV,EACD,CAAC,YAAY,EAAEvD,YAAY,CAAC,gBAAgB,CAAC,EAAEe,gBAAgB,CAAC,EAChE,CAAC,YAAY,EAAEwC,oBAAS,EAAExC,gBAAgB,CAAC,CAC5C,CAAC,EACF;IACA2I,8BAA8B,CAAC9L,IAAI,EAAEQ,KAAK,CAAC;EAC7C;AACF;AAEO,SAAS8L,wBAAwBA,CACtCtM,IAAuB,EACvBuM,SAA2C,GAAG,SAAS,EAC/C;EACRlN,OAAO,CAACC,GAAG,CAAC,qDAAqD,CAAC;EAClE,MAAMkN,UAAuB,GAAG;IAC9BC,WAAW,EAAE,EAAE;IACf1D,UAAU,EAAE,IAAI2D,GAAG,CAAC,CAAC;IACrBzN,OAAO,EAAE,CAAC,CAAC;IACX0B,OAAO,EAAE,EAAE;IACX6F,SAAS,EAAE,EAAE;IACb4C,UAAU,EAAEpJ,IAAI,CAACZ,IAAI,CAACuN,UAAU,KAAK,QAAQ;IAC7CtG,iBAAiB,EAAE,IAAIuG,OAAO,CAAC;EACjC,CAAC;EAED,MAAMC,KAAK,GACTN,SAAS,KAAK,UAAU,GACpB,IAAAO,iCAAiB,EAAS9M,IAAI,EAAE,0BAA0B,CAAC,GAC3D+E,SAAS;EAEf,IAAIwH,SAAS,KAAK,SAAS,IAAIM,KAAK,aAALA,KAAK,eAALA,KAAK,CAAEvG,GAAG,CAACtG,IAAI,CAAC,EAAE;IAAA,IAAA+M,UAAA;IAC/C,QAAAA,UAAA,GAAOF,KAAK,CAAC3M,GAAG,CAACF,IAAI,CAAC,cAAA+M,UAAA,cAAAA,UAAA,GAAIP,UAAU;EACtC;EAEAxM,IAAI,CAACyB,QAAQ,CACX;IACEuL,oBAAoB,EAAE9B,+BAA+B;IACrD+B,cAAc,EAAEd,yBAAyB;IACzCe,oBAAoB,EAAE/C,+BAA+B;IACrDgD,wBAAwB,EAAEnC,mCAAmC;IAC7DoC,sBAAsB,EAAE5C,iCAAiC;IACzD6C,iBAAiB,EAAE9M,4BAA4B;IAC/C+M,MAAM,EAAEpJ,wBAAwB;IAChCxC,UAAU,EAAE6H,2BAA2B;IACvCgE,kBAAkB,EAAE1G;EACtB,CAAC,EACD2F,UACF,CAAC;EAED,MAAM;IAAEnG,iBAAiB;IAAE,GAAG7F;EAAM,CAAC,GAAGgM,UAAU;EAElDK,KAAK,aAALA,KAAK,eAALA,KAAK,CAAE7D,GAAG,CAAChJ,IAAI,EAAEQ,KAAK,CAAC;EAEvB,OAAOA,KAAK;AACd","ignoreList":[]}